<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="操作系统 进程和线程进程和线程有什么区别？ 展开   进程（Process）是系统资源分配的基本单位; 线程（Thread）是CPU调度和执行的基本单位 进程是运行中的程序; 线程是进程内部的一个执行序列 包含关系: 一个进程至少有一个线程; 线程依赖于进程而存在, 线程是进程的一部分 内存分配: 进程间的地址空间(代码段, 数据段)相互独立; 线程共享所属进程的地址空间 进程是拥有系统资源的一个">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://example.com/2021/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Abyss">
<meta property="og:description" content="操作系统 进程和线程进程和线程有什么区别？ 展开   进程（Process）是系统资源分配的基本单位; 线程（Thread）是CPU调度和执行的基本单位 进程是运行中的程序; 线程是进程内部的一个执行序列 包含关系: 一个进程至少有一个线程; 线程依赖于进程而存在, 线程是进程的一部分 内存分配: 进程间的地址空间(代码段, 数据段)相互独立; 线程共享所属进程的地址空间 进程是拥有系统资源的一个">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/2021/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/_v_images/20191202090217863_1873.png">
<meta property="og:image" content="http://example.com/2021/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/_v_images/20191202162008435_14938.png">
<meta property="article:published_time" content="2021-03-02T16:18:48.000Z">
<meta property="article:modified_time" content="2021-03-02T16:19:12.909Z">
<meta property="article:author" content="VastRock-Huang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/_v_images/20191202090217863_1873.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/2021/03/03/操作系统/"/>





  <title>操作系统 | Abyss</title>
  








<meta name="generator" content="Hexo 5.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Abyss</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Abyss">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">操作系统</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-03T00:18:48+08:00">
                2021-03-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><hr>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程和线程有什么区别？"><a href="#进程和线程有什么区别？" class="headerlink" title="进程和线程有什么区别？"></a>进程和线程有什么区别？</h3><details>
<summary>展开</summary>

<ul>
<li>进程（Process）是<strong>系统资源分配的基本单位</strong>; 线程（Thread）是<strong>CPU调度和执行的基本单位</strong></li>
<li>进程是运行中的程序; 线程是进程内部的一个执行序列</li>
<li>包含关系: <strong>一个进程至少有一个线程</strong>; 线程依赖于进程而存在, <strong>线程是进程的一部分</strong></li>
<li>内存分配: 进程间的<strong>地址空间(代码段, 数据段)相互独立</strong>; 线程<strong>共享所属进程的地址空间</strong></li>
<li>进程是拥有<strong>系统资源的一个独立单位</strong>, 每个进程都有独立的地址空间, 打开的文件、信号量、所属用户id、进程控制块; 而线程本身基本上不拥有系统资源，只拥有一点<strong>在运行中必不可少的资源(如程序计数器PC,一组寄存器,栈,TLS,状态)**，和其他线程</strong>共享本进程的相关资源**如堆、I/O、等；</li>
<li>进程切换时，涉及到整个当前进程CPU环境的保存和环境的设置, 以及新被调度运行的进程的CPU环境的设置, <strong>切换有较大开销</strong>; 而线程切换只需保存和设置少量的寄存器的内容，不涉及存储器管理方面的操作, <strong>线程切换的开销较小, 速度更快</strong>.</li>
<li>进程之间的通信需要以<strong>IPC(进程间通信)的方式进行, 如管道, 共享内存, 消息队列, 套接字等, 通讯困难</strong>；线程间可以<strong>直接读写进程数据段（如全局变量）来进行通信</strong>, 但需要线程同步和互斥手段的辅助以保证数据的一致性, <strong>通讯更方便</strong></li>
<li>多进程程序中<strong>一个进程崩溃(保护模式下)并不会对其它进程造成影响</strong>(因为进程地址空间独立); 多线程程序<strong>只要有一个线程崩溃，整个程序就会崩溃</strong>. 因此多进程比多线程更加健壮</li>
<li>进程有程序运行的入口、顺序执行序列和程序出口, <strong>进程可以独立执行; 线程不能独立执行</strong>, 必须依附于进程存在</details>

</li>
</ul>
<h4 id="同一进程中的线程可以共享哪些数据？"><a href="#同一进程中的线程可以共享哪些数据？" class="headerlink" title="同一进程中的线程可以共享哪些数据？"></a>同一进程中的线程可以共享哪些数据？</h4><details>
<summary>展开</summary>

<ul>
<li>进程<strong>代码段</strong></li>
<li>进程的<strong>公有数据（全局变量、静态变量…）</strong></li>
<li>进程<strong>打开的文件描述符</strong></li>
<li>进程的<strong>当前(工作)目录</strong></li>
<li><strong>信号处理器/信号处理函数</strong>：对收到的信号的处理方式</li>
<li><strong>进程ID与进程组ID</strong></details>

</li>
</ul>
<h4 id="线程独占哪些资源？"><a href="#线程独占哪些资源？" class="headerlink" title="线程独占哪些资源？"></a>线程独占哪些资源？</h4><details>
<summary>展开</summary>

<ul>
<li><strong>线程ID</strong></li>
<li><strong>TLS</strong>: Thread Local Storage, 线程局部存储</li>
<li><strong>一组寄存器的值</strong>(包括<strong>程序计数器PC</strong>)</li>
<li>线程自身的<strong>栈</strong>（堆是共享的）</li>
<li><strong>错误返回码</strong>：线程可能会产生不同的错误返回码，一个线程的错误返回码不应该被其它线程修改；</li>
<li><strong>信号掩码/信号屏蔽字</strong>(Signal mask)：表示是否屏蔽/阻塞相应的信号（SIGKILL,SIGSTOP除外）</li>
<li><strong>线程优先级</strong></details>

</li>
</ul>
<h3 id="进程间通信有哪些方式？"><a href="#进程间通信有哪些方式？" class="headerlink" title="进程间通信有哪些方式？"></a>进程间通信有哪些方式？</h3><ol>
<li>匿名管道(Pipe)<details>
<summary>展开</summary>
</li>
</ol>
<ul>
<li>管道是<strong>单工的, 数据只能向一个方向流动</strong>. 需要双方通信时，需要建立起两个管道；进程间通信方式</li>
<li>管道的实质是一个内核缓冲区, 进程以<strong>先进先出</strong>(FIFO)方式从缓冲区存取数据, <strong>一个进程向管道中写的数据被管道另一端的进程读出</strong>. 当缓冲区写满或者读空的时候，相应的进程会进入等待队列.</li>
<li>面向字节流</li>
<li>只能用于父子进程或者兄弟进程之间(具<strong>有亲缘关系的进程</strong>)</li>
<li>Linux中, 使用 <code>pipe()</code>函数创建匿名管道, <strong>无需显示打开, 退出后自动释放</strong>. 其中<code>fd[0]</code>用于读数据, <code>fd[1]</code>用于写数据; 每个进程需要使用<code>close()</code>函数关闭一端, 另一端使用文件I/O<code>read()</code>或<code>write()</code>函数进行读写.</details>
</li>
</ul>
<ol start="2">
<li>命名管道(FIFO)<details>
<summary>展开</summary>
</li>
</ol>
<ul>
<li>提供一个<strong>路径名与之关联</strong>，以FIFO的<strong>文件形式存储文件系统</strong>中(可控制所有权和权限), 但 FIFO 中的<strong>内容却存放在内存</strong>, 通信的两进程结束后会丢失, 但文件路径仍存在</li>
<li><strong>允许无亲缘关系进程间的通信</strong>, 且允许多个进程通过其通信</li>
<li><strong>半双工</strong>的通信方式, 单向传输数据, 但两端都可用来读写</li>
<li>Linux中, 使用<code>mkfifo()</code>或<code>mknod()</code>函数创建命名管道, <strong>需要使用<code>open()</code>函数显示打开</strong>和<code>close()</code>关闭, 采用文件I/O<code>read()</code>和<code>write()</code>读写</details>
</li>
</ul>
<ol start="3">
<li>消息队列<details>
<summary>展开</summary>
</li>
</ol>
<ul>
<li>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。</li>
<li><strong>存放在内核</strong>(的内存)中，只有在<strong>内核重启</strong>(即操作系统重启)或者<strong>显示地删除</strong>时，该消息队列才会被真正的删除</li>
<li>允许一个或多个进程向它写入或者读取消息，并且<strong>每条消息都有类型</strong></li>
<li>消息队列可以实现<strong>消息的随机查询</strong>, 消息可以<strong>按先进先出的次序</strong>读取, 也可以<strong>按消息的类型</strong>读取(第一个).</li>
<li>与无名管道、有名管道一样，从消息队列中读出消息，消息队列中数据会被删除。</li>
<li>在Linux中, 使用<code>msgget()</code>函数创建消息队列, 使用<code>msgsnd()</code>函数向队列添加消息, 使用<code>msgrcv()</code>(可以按类型)</details>
</li>
</ul>
<ol start="4">
<li>信号(Signal)<details>
<summary>展开</summary>
</li>
</ol>
<ul>
<li>信号可<strong>由进程, 操作系统内核和硬件发送</strong>. 可在<strong>任何时候</strong>发给某一进程，而无需知道该进程的状态, 是进程间<strong>唯一的一种异步通信方式</strong></li>
<li><ul>
<li>信号产生时会<strong>设置此信号传递的对象</strong>（一般为对应进程的pid）, 然后传递给操作系统；</li>
<li>操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果该进程处于阻塞状态并未执行，则该信号就有内核保存起来，直到该进程恢复执行并传递给它为止; 如果对应进程已经退出，则丢弃此信号;  如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞,  如果对应进程没有阻塞，操作系统将传递此信号。</li>
<li>目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时<strong>终止当前代码的执行，保护上下文</strong>（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而**执行中断服务程序(即相应的信号处理函数)**，执行完成后在回复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。</li>
</ul>
</li>
<li>Linux中定义了62种信号, 常用的有<code>SIGINT</code> <code>SIGQUIT</code> <code>SIGALRM</code> 等, <strong>使用<code>kill(pid, sig)</code>函数发送信号, 使用<code>signal(sig, func)</code>函数注册信号处理函数</strong>.</details>


</li>
</ul>
<ol start="5">
<li>共享内存<details>
<summary>展开</summary>
</li>
</ol>
<ul>
<li>内核专门留出了一块内存区，可以由需要访问的<strong>进程将其映射到自己的私有地址空间</strong>(进程的逻辑地址有页表转换为物理地址后相同).</li>
<li>使得多个进程可以可以直接读写<strong>同一块物理内存空间</strong>，不需要系统调用，不涉及用户态到内核态的转换，也不需要对数据不必要的复制. 是<strong>最快</strong>的可用IPC形式.</li>
<li><strong>存在并发问题, 需要依靠某种同步机制</strong>（如信号量）来达到进程间的同步及互斥。</li>
<li><strong>生命周期也是随内核</strong>, 使用命令删除一个共享内存的时候，需要等到所有进程都<strong>与共享内存解除映射之后才删除</strong></li>
<li>Linux中, 使用<code>shmget()</code>函数创建共享内存; <code>shmat()</code>函数把共享内存映射到调用进程空间(挂接到进程的页表), 返回共享内存虚拟地址; 使用<code>shmdt()</code>函数断开进程与共享内存的绑定.</details>
</li>
</ul>
<ol start="6">
<li>信号量(Semaphore)</li>
</ol>
<details>
<summary>展开</summary>

<ul>
<li>信号量可以<strong>用于实现进程或线程的互斥和同步</strong>, 并<strong>不用来进行数据传输</strong>.</li>
<li>是一种特殊的变量，对它的操作都是原子的. </li>
<li>有两种操作：<strong>P操作：信号量-1</strong>，若<strong>小于0，则进程进入阻塞状态</strong>；<strong>V操作：信号量+1</strong>，若<strong>小于等于0，则从队列中唤醒一个等待的进程进入就绪态</strong></li>
<li>Linux中, 使用<code>semget()</code>函数创建或获得信号量; 使用<code>semop()</code>进行P或V操作(信号量+1-1); 使用<code>semctl()</code>设置信号量如SETVAL用于设置信号量初值, IPC_RMID删除信号量</details>
</li>
</ul>
<ol start="7">
<li>套接字(Socket)</li>
</ol>
<ul>
<li>Ref: <ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c1015f5ffa74">进程间通信IPC (InterProcess Communication) - 简书</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/109550924">浅析进程间通信的几种方式（含实例源码） - 知乎</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ludan_xia/article/details/105653707">进程间七种通信方法，IPC的各种应用场景和优缺点 - CSDN</a></li>
<li><a target="_blank" rel="noopener" href="https://imageslr.github.io/2020/02/26/ipc.html#%E7%AE%A1%E9%81%93-pipe">【操作系统】进程间的通信方式 - GitHub</a></li>
</ul>
</li>
</ul>
<h3 id="进程有哪几种状态？"><a href="#进程有哪几种状态？" class="headerlink" title="进程有哪几种状态？"></a>进程有哪几种状态？</h3><p><img src="_v_images/20191202090217863_1873.png" alt="Process State"></p>
<ul>
<li>运行状态：进程<strong>占用CPU, 在CPU上运行</strong>, 处于此状态的进程数小于等于CPU数</li>
<li>就绪状态：进程已获得除CPU外的所需资源<strong>具备运行条件, 等待分配CPU资源</strong></li>
<li>阻塞状态：进程<strong>等待某项服务完成或信号到来</strong>等条件, 在条件满足之前无法执行</li>
</ul>
<h3 id="进程调度策略有哪些"><a href="#进程调度策略有哪些" class="headerlink" title="进程调度策略有哪些"></a>进程调度策略有哪些</h3><h4 id="1-批处理系统"><a href="#1-批处理系统" class="headerlink" title="1 批处理系统"></a>1 批处理系统</h4><p>批处理系统目标是: 最大化每小时作业数, 最小化从提交到完成的时间间隔（衡量了用户等待一个输出的平均时间), 保持CPU始终忙碌</p>
<ol>
<li><strong>先来先服务</strong>调度算法 first-come first-serverd (FCFS)<details>
<summary> 展开 </summary>
</li>
</ol>
<ul>
<li>既可用于进程调度，也可用于作业调度。<ul>
<li>在进程调度中采用FCFS算法时，则每次调度是<strong>从就绪队列中选择一个最先进入该队列的进程</strong>，为之分配处理机</li>
<li>在作业调度中时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列</li>
<li><strong>非抢占式</strong>，开销小，<strong>无饥饿问题</strong>，响应时间不确定(可能很慢)</li>
<li>只考虑作业的等候时间, 没考虑运行时间长短. <strong>对短进程不利, 对I/O密集型进程不利</strong></details>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>短作业优先</strong>调度算法 shortest job first（SJF）<details>
<summary>展开</summary>
</li>
</ol>
<ul>
<li>按估计<strong>运行时间最短的顺序</strong>进行调度</li>
<li>可以分别用于作业调度和进程调度。<ul>
<li>从就绪队列中<strong>选出一个估计运行时间最短的进程</strong>，将处理机分配给它，使它<strong>立即执行并一直执行到完成</strong>，或 发生某事件而被阻塞放弃处理机时再重新调度。</li>
<li>短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内 存运行。</li>
</ul>
</li>
<li><strong>非抢占式</strong>，吞吐量高，开销可能较大，<strong>可能导致饥饿</strong>问题；</li>
<li>对短进程提供好的响应时间，对长进程不利。</details>
</li>
</ul>
<ol start="3">
<li><strong>最短剩余时间优先</strong> shortest remaining time next（SRTN）<details>
<summary>展开</summary>
</li>
</ol>
<ul>
<li>按<strong>剩余运行时间的顺序</strong>进行调度。</li>
<li><strong>最短作业优先的抢占式版本</strong>。若新就绪的进程运行时间比正在执行的进程剩余运行时间短，则新进程将抢占CPU</li>
<li>吞吐量高，开销可能较大，提供好的响应时间, <strong>可能导致饥饿问题</strong>，对长进程不利。</details>
</li>
</ul>
<ol start="4">
<li><strong>最高响应比优先</strong> Highest Response Ratio Next（HRRN）<details>
<summary>展开</summary>
</li>
</ol>
<ul>
<li><strong>响应比 = 响应时间 / 运行时间 = (等待时间 + 运行时间) / 运行时间 = 1+ 等待时间/运行时间</strong>. </li>
<li>选择<strong>响应比最高的作业优先投入运行</strong>.</li>
<li>同时考虑了等待时间的长短和估计需要的执行时间长短，很好的平衡了长短进程。</li>
<li><strong>非抢占</strong>，吞吐量高，开销可能较大(每次调度前都要计算响应比)，提供好的响应时间，<strong>无饥饿问题</strong>。</details>

</li>
</ul>
<h4 id="2-交互式系统"><a href="#2-交互式系统" class="headerlink" title="2. 交互式系统"></a>2. 交互式系统</h4><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p>
<ol>
<li><strong>时间片轮转</strong> Round Robin<details>
<summary>展开</summary>
</li>
</ol>
<ul>
<li>将所有<strong>就绪进程按 先进先出(FCFS) 的原则排成一个队列</strong>. 进程<strong>以时间片为单位轮流使用CPU</strong>, 刚用完时间片的进程排到队列最后。</li>
<li>每个就绪进程都有机会获得CPU(公平性), 且等待有限时间就可重新获得CPU(交互性)</li>
<li><strong>抢占式（时间片用完时）</strong>，开销小，<strong>无饥饿问题</strong>，为短进程提供好的响应时间</li>
<li>若时间片小，进程切换频繁，吞吐量低；若时间片太长，实时性得不到保证。</details>
</li>
</ul>
<ol start="2">
<li><strong>优先级</strong>调度算法<details>
<summary>展开</summary>
</li>
</ol>
<ul>
<li>为每个进程分配一个优先级，按优先级进行调度(选择<strong>优先级最高的进程分配CPU</strong>)</li>
<li>进程的<strong>优先级分为静态优先级和动态优先级</strong>.<ul>
<li>静态优先级创建时确定, 运行时不变. 基于进程所需资源,运行时间,进程类型确定</li>
<li>动态优先级在进程运行时可以改变: 当进程使用CPU超过一定时长(降低),进行I/O操作(升高),等待超过一定时长(升高)都会改变.</li>
</ul>
</li>
<li><strong>分为抢占式和非抢占式</strong>. 前者当系统中出现优先权更高的进程，则立即停止当前执行，并将处理机分配给新到的优先权最高的进程; 后者则在原进程执行完后在分配给新进程.</details>
</li>
</ul>
<ol start="3">
<li>多级反馈队列调度算法 Multilevel Feedback Queue<details>
<summary>展开</summary>
</li>
</ol>
<ul>
<li>设置<strong>多个就绪队列</strong> 1、2、3…，<strong>优先级递减，时间片递增</strong>。进程在进入待调度的队列等待时，首先进入优先级最高的Q1等待</li>
<li>只有等到<strong>优先级更高的队列为空时才会调度当前队列中的进程</strong>。如果<strong>进程用完了当前队列的时间片还未执行完，则会被移到下一队列</strong>。若此时已经是在最下级的队列，则重新放回该队列队尾。</li>
<li>抢占式: 时间片用完时会被下一进程抢占; 有<strong>高优先级的进程到达, 则放弃正在调度的进程(放回当前队列的队尾)，转向调度最高优先级的进程</strong></li>
<li>同一个队列中的各个进程，按照时间片轮转法调度</li>
<li>开销可能较大，对IO型进程有利，可能会出现饥饿问题。</details>

</li>
</ul>
<h4 id="什么叫优先级反转？如何解决？"><a href="#什么叫优先级反转？如何解决？" class="headerlink" title="什么叫优先级反转？如何解决？"></a>什么叫优先级反转？如何解决？</h4><details>
<summary>展开</summary>

<ul>
<li><p><strong>高优先级的进程等待被一个低优先级进程占用的资源</strong>时，就会出现优先级反转，即<strong>优先级较低的进程比优先级较高的进程先执行</strong>。</p>
</li>
<li><p>解决方法：</p>
<ul>
<li>优先级天花板(priority ceiling)：当任务申请某资源时，<strong>把该任务的优先级提升到</strong>可访问这个资源的*<em>所有任务中的最高优先级**</em>，这个优先级称为该资源的优先级天花板。简单易行。</li>
<li>优先级继承(priority inheritance)：当任务A申请共享资源S时，如果S正在被任务C使用，通过比较任务C与A自身的优先级，如发现任务C的优先级小于A自身的优先级，则<strong>将任务C的优先级提升到A自身的优先级</strong>，任务C释放资源S后，再恢复任务C的原优先级。</details>

</li>
</ul>
</li>
</ul>
<h3 id="什么是僵尸进程？"><a href="#什么是僵尸进程？" class="headerlink" title="什么是僵尸进程？"></a>什么是僵尸进程？</h3><details>
<summary>展开</summary>

<ul>
<li>一个进程使用fork创建子进程, 当<strong>子进程比父进程先结束</strong>，而<strong>父进程又 没有调用 <code>wait</code> 或者 <code>waitpid</code> 回收子进程</strong>，释放子进程占用的资源, 那么这个子进程将成为一个僵尸进程。</li>
<li>系统调用 <code>exit</code> 的作用是使进程退出，仅限于将一个正常的进程变成一个僵尸进程，并不能将其完全销毁。</li>
<li>一个进程在调用exit命令结束自己生命的时候，并没有真正的被销毁，而是留下一个称为僵尸进程（Zombie）的数据结构。它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，<strong>仅在进程表中保留一个位置，记载该进程的进程ID、退出状态以及资源利用信息(CPU时间，内存使用量等等)等供父进程收集</strong>，除此之外，僵尸进程不再占有任何内存空间。</li>
<li>若父进程结束，则init进程自动会接手这个子进程，对其回收. 但是如果<strong>父进程</strong>是一个循环，<strong>不会结束</strong>，那么<strong>子进程将一直保持僵尸状态, 一直留在系统中直到系统重启</strong>。</li>
<li>危害：<strong>占用进程号</strong>，而系统所能使用的进程号是有限的；<strong>占用内存</strong>。</li>
<li>避免(不会产生僵尸进程)：<ol>
<li><strong>结束父进程, 让僵尸进程变为孤儿进程, 由init进程接管并回收</strong>。每个进程结束的时候，系统都会扫描是否存在子进程，如果有则用Init进程接管，成为该进程的父进程，并且会调用wait等待其结束。</li>
<li><strong>父进程调用 wait 或者 waitpid 等待子进程结束</strong>（需要<strong>每隔一段时间查询</strong>子进程是否结束）。<ul>
<li>wait系统调用会使父进程暂停执行，直到它的一个子进程结束为止。</li>
<li>waitpid则可以加入<code>WNOHANG</code>(wait-no-hang) 选项，如果没有发现结束的子进程，就会立即返回，不会将调用 waitpid 的进程阻塞。同时，waitpid还可以选择是等待任一子进程（同wait），还是等待指定pid的子进程，还是等待同一进程组下的任一子进程，还是等待组ID等于pid的任一子进程；</li>
</ul>
</li>
<li><strong>捕捉 SIGCHLD 信号，并在信号处理函数中调用wait或waitpid函数</strong>. <strong>子进程结束时，系统会产生 SIGCHLD(signal-child) 信号</strong>，可以注册一个信号处理函数，在该函数中调用waitpid，等待所有结束的子进程（注意：一般都需要循环调用waitpid，因为在信号处理函数开始执行之前，可能已经有多个子进程结束了，而信号处理函数只执行一次，所以要循环调用将所有结束的子进程回收）；</li>
<li>父进程不关心子进程什么时候结束, 可以<strong>用<code>signal(SIGCLD, SIG_IGN)</code>(signal-ignore)通知内核，表示忽略<code>SIGCHLD</code>信号</strong>，那么子进程结束后，<strong>内核会进行回收</strong>。</details>

</li>
</ol>
</li>
</ul>
<h3 id="什么是孤儿进程？"><a href="#什么是孤儿进程？" class="headerlink" title="什么是孤儿进程？"></a>什么是孤儿进程？</h3><details>
<summary>展开</summary>

<p>一个<strong>父进程已经结束了，但是它的子进程还在运行</strong>，那么这些子进程将成为孤儿进程。<br><strong>孤儿进程会被init</strong>（进程ID为1, 用户机开启时开始工作，在用户机结束时终止）<strong>接管</strong>，当这些孤儿进程结束时由Init<strong>完成状态收集工作</strong>。</p>
</details>

<h3 id="并发、并行、异步"><a href="#并发、并行、异步" class="headerlink" title="并发、并行、异步"></a>并发、并行、异步</h3><details>
<summary>展开</summary>

<ul>
<li>并发：在<strong>一个时间段</strong>中同时有多个程序在运行，但微观上<strong>任一时刻只有一个程序在CPU上运行</strong>，宏观上的并发是通过不断的切换实现的；</li>
<li>并行（和串行相对）：在多CPU系统中，多个程序无论<strong>宏观还是微观上都是同时执行的</strong></li>
<li>异步（和同步相对）：异步是<strong>过程调用发出后</strong>，调用者<strong>在没有得到结果之前，就可以继续执行后续操作</strong>。当这个调用完成后，一般<strong>通过状态、通知和回调来通知</strong>调用者。(同步是发出一个功能调用时，<strong>在没有得到结果之前，该调用就不返回或不继续执行后续操作</strong>)</li>
<li>多线程：并发或并行运行的一段代码, 是实现异步的手段</details>


</li>
</ul>
<h3 id="进程同步问题"><a href="#进程同步问题" class="headerlink" title="进程同步问题"></a>进程同步问题</h3><p>进程的同步是目的，而进程间通信是实现进程同步的手段</p>
<h4 id="临界资源和临界区"><a href="#临界资源和临界区" class="headerlink" title="临界资源和临界区"></a>临界资源和临界区</h4><details>
<summary>展开</summary>

<ul>
<li>临界资源: <strong>一次只允许一个进程独占访问使用</strong>的资源</li>
<li>临界区: 各个进程中<strong>对临界资源进行操作的程序片段</strong></details>

</li>
</ul>
<h4 id="进程的同步与互斥"><a href="#进程的同步与互斥" class="headerlink" title="进程的同步与互斥"></a>进程的同步与互斥</h4><details>
<summary>展开</summary>

<ul>
<li>同步：<strong>多个进程因为合作</strong>而使得进程的执行有一定的先后顺序。<strong>一个进程执行到某一步时，必须等待另一个进程</strong>发来信息才能继续运行下去. </li>
<li>互斥：多个进程在<strong>同一时刻只有一个进程能进入临界区</strong>访问临界资源</details>

</li>
</ul>
<h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h4><ul>
<li>问题描述：使用一个缓冲区来存放数据. 只有缓冲区没有满，生产者才可以写入数据；只有缓冲区不为空，消费者才可以读出数据. <strong>每个时刻只有1个</strong>生产者或消费者能存或取缓冲区. </li>
<li>伪代码实现：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义信号量</span></span><br><span class="line">semaphore full = <span class="number">0</span>;    <span class="comment">//缓冲区数据个数</span></span><br><span class="line">semaphore empty = n;    <span class="comment">//缓冲区空位个数 n为缓冲区大小</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;    <span class="comment">//缓冲区读写的互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者进程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">   	  P(empty);    <span class="comment">//有空位才写</span></span><br><span class="line">	  P(mutex);    <span class="comment">//互斥操作</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//生产者进行生产 - 存一个数据到缓冲区</span></span><br><span class="line">   	</span><br><span class="line">   	  V(mutex);</span><br><span class="line">   	  V(full);    <span class="comment">//有了数据,可唤醒阻塞的消费者进程</span></span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者进程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">	  P(full);    <span class="comment">//有数据才读</span></span><br><span class="line">	  P(mutex);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//消费者进行消费 - 从缓冲区读1个数据</span></span><br><span class="line"></span><br><span class="line">	  V(mutex);</span><br><span class="line">	  V(empty);    <span class="comment">//有了空位,可唤醒阻塞的生产者进程</span></span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h4><ul>
<li>问题描述: 有一本书. 有多个读者读书, 有多个读者编书. 要求: 允许多个读者同时读书(可多个用户读操作), 不允许读者编者同时操作(读写互斥), 不允许多个编者同时操作(写操作互斥).</li>
<li>伪代码实现:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//信号量</span></span><br><span class="line">semaphore readCount = <span class="number">0</span>;    <span class="comment">//读者计数</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;        <span class="comment">//readCount的互斥量</span></span><br><span class="line">semaphore editor = <span class="number">1</span>;        <span class="comment">//编者读者的互斥量</span></span><br><span class="line"><span class="comment">//semaphore editorFirst = 1;    //实现编者优先的互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读者进程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//P(editorFirst);    //没有编者时可以增加读者人数</span></span><br><span class="line">                             <span class="comment">//否则会阻塞, 不允许继续添加读者</span></span><br><span class="line">        P(mutex);            <span class="comment">//readCount互斥操作</span></span><br><span class="line">        ++readCount;</span><br><span class="line">        <span class="keyword">if</span>(readCount == <span class="number">1</span>)    <span class="comment">//有读者时</span></span><br><span class="line">            P(editor);        <span class="comment">//读者与编者互斥</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        <span class="comment">//V(editorFirst);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//读者读书</span></span><br><span class="line"></span><br><span class="line">        P(mutex);</span><br><span class="line">        --readCount;</span><br><span class="line">        <span class="keyword">if</span>(readCount == <span class="number">0</span>)    <span class="comment">//没有读者时</span></span><br><span class="line">            V(editor);        <span class="comment">//允许编者写书</span></span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编者进程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Editor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//P(editorFirst);    //有编者时</span></span><br><span class="line">        P(editor);    <span class="comment">//读者编者互斥</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//编者编书</span></span><br><span class="line">    </span><br><span class="line">        V(editor);</span><br><span class="line">        <span class="comment">//V(editorFirst);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>以上解法为读者优先. 有读者则编者一直无法编写, 可能会造成读者饥饿.</li>
<li>带信号量<code>editorFirst</code>后为写者优先. 当有写者要进行写操作时, 便不允许后续增加读者, 而是等写者编写完后才能增加.</li>
</ol>
<h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><ul>
<li><p>问题描述：有 n (5) 位哲学家围绕着餐桌坐，每一位哲学家要么思考，要么吃饭。为了吃饭，哲学家必须拿起两双筷子（分别放于左右两端）不幸的是，筷子的数量和哲学家相等，所以每只筷子必须由两位哲学家共享。要求: 拿一双筷子才能吃饭, 每次只能取一支, 只能拿身边的筷子, 吃完饭才放下筷子</p>
</li>
<li><p>该问题会导致死锁, 避免死锁有多种策略.</p>
<ul>
<li><p>策略1: <strong>限制就餐人数. 至多允许 n-1 个哲学家同时进餐</strong>. 这样能够保证至少一位哲学家能够就餐, 从而进餐后能够释放资源供其他哲学家使用.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopsticks[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;<span class="comment">//筷子的互斥信号量</span></span><br><span class="line">semaphore room = <span class="number">4</span>;     <span class="comment">//能够进餐的人数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">		think();</span><br><span class="line">		P(room);    <span class="comment">//准备拿筷子进餐, 进餐会占用1个位置</span></span><br><span class="line">		            <span class="comment">//当没有位置时阻塞, 禁止拿筷子进餐</span></span><br><span class="line">		P(chopstick[i]);</span><br><span class="line">		P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">		eat();    <span class="comment">//进餐</span></span><br><span class="line">		V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">		V(chopstick[i]);</span><br><span class="line">		V(room);    <span class="comment">//进餐完毕, 可进餐人数+1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>策略2:预先分配资源. <strong>仅当哲学家左右筷子都能拿起时才会让其进餐</strong>. 具体实现为使用互斥量确保每次仅有一个人能够拿筷子, <strong>拿完一双后, 下一个人才能拿筷子(相当于将拿一双筷子变为原子操作)</strong>. 这样就不会出现每个人只拿一只筷子的情况.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;  <span class="comment">//取筷子互斥信号量, 每次仅一人能拿筷子</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">     	think();</span><br><span class="line">     	P(mutex);    <span class="comment">//拿筷子信号量, 有它人取筷子时会阻塞</span></span><br><span class="line">     	P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">     	P(chopstick[i]);</span><br><span class="line">     	V(mutex);    <span class="comment">//拿完筷子,其他人可以拿筷子</span></span><br><span class="line">     	eat();</span><br><span class="line">     	V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 释放右手边的筷子</span></span><br><span class="line">     	V(chopstick[i]); <span class="comment">// 释放左手边的筷子</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure></li>
<li><p>策略3: 规定奇数号的哲学家先拿起他左边的筷子，然后再去拿他右边的筷子；而偶数号的哲学家则先拿起他右边的筷子，然后再去拿他左边的筷子。按此规定，将是1、2号哲学家竞争1号筷子，3、4号哲学家竞争3号筷子。即五个哲学家都竞争奇数号筷子，获得后，再去竞争偶数号筷子，最后总会有一个哲学家能获得两支筷子而进餐。</p>
</li>
</ul>
</li>
</ul>
<h4 id="管程-Monitor"><a href="#管程-Monitor" class="headerlink" title="管程 Monitor"></a>管程 Monitor</h4><ul>
<li>管程<strong>将共享变量以及对这些共享变量的操作封装起来，形成一个具有一定接口的功能模块</strong>，这样只能通过管程提供的某个过程才能访问管程中的资源。<strong>进程只能互斥地使用管程，使用完之后必须释放管程</strong>并唤醒入口等待队列中的进程。</li>
<li>HOARE管程: <ul>
<li>当一个进程试图进入管程时，在<strong>入口等待队列</strong>等待。若P进程唤醒了Q进程，则Q进程先执行，P在<strong>紧急等待队列</strong>中等待。</li>
<li>wait操作：执行wait操作的进程进入条件变量链末尾，唤醒紧急等待队列或者入口队列中的进程；signal操作：唤醒条件变量链中的进程，自己进入紧急等待队列，若条件变量链为空，则继续执行。</li>
</ul>
</li>
<li>MESA管程：<ul>
<li>将HOARE中的signal换成了notify（或者broadcast通知所有满足条件的），进行通知而不是立马交换管程的使用权，在合适的时候，条件队列首位的进程可以进入，进入之前必须用while检查条件是否合适。</li>
<li>优点：没有额外的进程切换</li>
</ul>
</li>
</ul>
<h3 id="Linux线程同步有哪些方式？"><a href="#Linux线程同步有哪些方式？" class="headerlink" title="Linux线程同步有哪些方式？"></a>Linux线程同步有哪些方式？</h3><h4 id="1-互斥锁-mutex"><a href="#1-互斥锁-mutex" class="headerlink" title="1.互斥锁(mutex):"></a>1.互斥锁(mutex):</h4><ul>
<li>锁机制是同一时刻只允许一个线程访问临界区/临界资源. 强调的是资源的访问互斥</li>
<li>互斥锁必须总是由给它上锁的线程解锁.</li>
<li>互斥锁只有”锁住”和”解开”两种转态.</li>
<li>Linux中, 线程的互斥量数据类型是<code>pthread_mutex_t</code>. 在使用前, 要使用<code>pthread_mutex_init()</code>进行初始化; 使用<code>pthread_mutex_lock()</code>(阻塞)或<code>pthread_mutex_trylock()</code>(非阻塞) 进行加锁; 使用<code>pthread_mutex_unlock()</code>进行解锁; 使用<code>pthread_mutex_destroy()</code>销毁锁.<h4 id="2-条件变量-cond"><a href="#2-条件变量-cond" class="headerlink" title="2.条件变量(cond)"></a>2.条件变量(cond)</h4></li>
<li>条件变量是利用线程间共享全局变量进行<strong>同步</strong>的一种机制。</li>
<li>条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。</li>
<li>Linux中使用<code>pthread_cond_init()</code>初始化条件变量, 使用<code>pthread_cond_wait()</code>或<code>pthread_cond_timewait</code>进行无条件等待或计时等待. 使用<code>pthread_cond_signal()</code>激活条件变量解除线程的阻塞, 使用<code>pthread_cond_broadcast</code>激活所有等待线程</li>
<li>必须和一个互斥锁配合，以防止多个线程同时请求竞争条件（Race Condition）. 且在等待前须有本线程加锁（pthread_mutex_lock()）</li>
</ul>
<h4 id="3-读写锁"><a href="#3-读写锁" class="headerlink" title="3.读写锁"></a>3.读写锁</h4><ul>
<li><p>与互斥锁类似. 但读写锁可以有三种状态：读模式下加锁状态，写模式下加锁状态，不加锁状态。一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。</p>
</li>
<li><p>当读写锁以读模式锁住时，它是以共享模式锁住的；当他以写模式锁住时，它是以独占模式锁住的。读读共享，读写互斥.</p>
</li>
<li><p>写模式加锁优先. 当读写锁处于读模式锁住状态时，如果有另外的线程试图以写模式加锁，读写锁通常会阻塞随后的读模式锁请求</p>
</li>
<li><p>可用于解决读者-写者问题.</p>
</li>
<li><p>Linux中, 使用<code>pthread_rwlock_init()</code>初始化读写锁. 使用<code>pthread_rwlock_rdlock()</code>加读锁，使用<code>pthread_rwlock_wrlock()</code>加写锁, 使用<code>pthread_rwlock_unlock()</code>释放读锁或者写锁</p>
<h4 id="4-信号量"><a href="#4-信号量" class="headerlink" title="4.信号量"></a>4.信号量</h4></li>
<li><p>轻量级信号量可用于线程间的同步与互斥. (信号量也可用于进程间同步与互斥)</p>
</li>
<li><p>Linux中使用<code>sem_init()</code>初始化信号量; <code>sem_wait()</code>相当于P操作, 信号量-1; <code>sem_post()</code>相当于V操作, 信号量+1, <code>sem_destory()</code>销毁信号量</p>
</li>
</ul>
<h3 id="什么是协程？"><a href="#什么是协程？" class="headerlink" title="什么是协程？"></a>什么是协程？</h3><ul>
<li>协程是一种<strong>用户态的轻量级线程</strong>，协程的<strong>调度完全由用户控制</strong>, 非抢占式.</li>
<li>协程拥<strong>有自己的寄存器上下文和栈</strong>。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈</li>
<li>协程<strong>能保留上一次调用时的状态</strong>（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，</li>
<li>协程是<strong>基于线程实现</strong>的，协程的创建、切换、销毁都是在某个线程中来进行的. <strong>一个线程可以包含多个协程</strong>.</li>
<li>协程的好处: <ul>
<li><strong>无需用户态到核态的转换</strong>, 寄存器需要保存和加载的数据量比较小, 因此<strong>切换速度快, 开销小</strong></li>
<li><strong>不需要多线程的锁机制</strong>，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态. <strong>协程的切换时机是开发者可控可知的</strong>, 因此无需互斥同步机制; 但也可以实现.</li>
<li>方便切换控制流，简化编程模型</li>
<li><strong>资源占用小</strong>, 初始一般为2KB, 可随需要增大</li>
</ul>
</li>
</ul>
<h3 id="协程与线程进行比较"><a href="#协程与线程进行比较" class="headerlink" title="协程与线程进行比较"></a>协程与线程进行比较</h3><details>
<summary>展开</summary>

<ol>
<li><strong>一个线程可以拥有多个协程</strong>，多协程也可用在多进程上运行</li>
<li>线程进程都是同步机制，而协程则是异步</li>
<li>协程<strong>能保留上一次调用时的状态</strong>，每次过程重入时，就相当于进入上一次调用的状态</li>
<li>协程占用资源比线程小</li>
<li>线程切换需要用户态和核态的转换, 而协程间切换无需用户态到核态的转换,换速度快更快, 开销更小</details>

</li>
</ol>
<h3 id="什么是IO多路复用？怎么实现？"><a href="#什么是IO多路复用？怎么实现？" class="headerlink" title="什么是IO多路复用？怎么实现？"></a>什么是IO多路复用？怎么实现？</h3><ul>
<li>IO多路复用（IO Multiplexing）是一种同步IO模型，<strong>实现单线程或单线程可以监视多个文件描述符；一旦某个描述符就绪，就能够通知程序进行相应的读写操作</strong>；没有文件描述符就绪时会阻塞应用程序，交出cpu。</li>
<li>实现原理：用户<strong>将想要监视的文件描述符（File Descriptor）添加到select/poll/epoll函数</strong>中，由<strong>内核监视</strong>，函数阻塞。一旦<strong>有文件描述符就绪</strong>（读就绪或写就绪），或者超时（设置timeout），函数就会返回，然后<strong>该进程可以进行相应的读/写操作</strong>。</li>
</ul>
<h3 id="select-poll-epoll及其区别"><a href="#select-poll-epoll及其区别" class="headerlink" title="select/poll/epoll及其区别"></a>select/poll/epoll及其区别</h3><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds,</span></span></span><br><span class="line"><span class="function"><span class="params">            fd_set *<span class="keyword">restrict</span> readfds,</span></span></span><br><span class="line"><span class="function"><span class="params">            fd_set *<span class="keyword">restrict</span> writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">            fd_set *<span class="keyword">restrict</span> errorfds,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct timeval *<span class="keyword">restrict</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>readfds</code>、<code>writefds</code>、<code>errorfds</code> 是三个文件描述符集合。select 会遍历每个集合的前 <code>nfds</code> 个描述符，分别找到可以读取、可以写入、发生错误的描述符，统称为“就绪”的描述符。然后用找到的子集替换参数中的对应集合，返回所有就绪描述符的总数。<code>timeout</code> 参数表示调用 select 时的阻塞时长。如果所有文件描述符都未就绪，就阻塞调用进程，<strong>直到某个描述符就绪，或者阻塞超过设置的 timeout 后，返回</strong>。如果 timeout 参数设为 NULL，会无限阻塞直到某个描述符就绪；如果 timeout 参数设为 0，会立即返回，不阻塞。</li>
<li>将文件描述符放入一个文件描述符集合<code>fd_set</code>中，每次调用select时，都将这个集合从用户空间拷贝到内核空间（缺点1：每次都要复制，<strong>开销大</strong>）由内核根据就绪状态修改该集合的内容。</li>
<li>文件描述符<strong>集合大小有限制</strong>（缺点2），导致同时能够监听的文件描述符数量太少, 32位机默认是1024（64位：2048）；采用水平触发机制。</li>
<li>select函数每次调用，需要通过遍历这个集合，找到就绪的文件描述符（缺点3：<strong>轮询的方式效率较低</strong>），当文件描述符的数量增加时，效率会线性下降；<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">( struct pollfd * fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>和select几乎没有区别，区别在于文件描述符的存储方式不同，<strong>poll采用链表的方式存储文件描述符，没有最大存储数量的限制</strong>；</li>
<li>和select同样都是通过轮询的方式来查询某个文件描述符状态是否发生了变化，并且需要将整个文件描述符集合在用户空间和内核空间之间来回拷贝<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>使用红黑树存储文件描述符集合, 使用队列存储就绪的文件描述符</li>
<li> epoll 对于每个描述符，只需要在 epoll_ctl 传递一次，之后 epoll_wait 不需要再次传递；通过事件更改文件描述符状态</li>
<li>epoll由事件驱动, epoll_ctl 中为每个文件描述符指定了回调函数，并在就绪时将其加入到就绪列表, 避免了轮询</li>
<li>支持水平触发和边缘触发. 采用边缘触发机制时，只有活跃的描述符才会触发回调函数。减少了事件被重复触发的次数.</li>
<li>通过内核和用户空间共享内存，避免了不断复制的问题；</li>
<li>支持的同时连接数上限很高（1G左右的内存支持10W左右的连接数）；</li>
</ul>
<p>总结，区别主要在于：</p>
<ul>
<li>一个线程/进程所能打开的最大连接数</li>
<li>文件描述符传递方式（是否复制）</li>
<li>水平触发 or 边缘触发</li>
<li>查询就绪的描述符时的效率（是否轮询）</details>

</li>
</ul>
<details>
<summary>什么时候使用select/poll，什么时候使用epoll？</summary>

<p>当连接数较多并且有很多的不活跃连接时，epoll的效率比其它两者高很多；但是当连接数较少并且都十分活跃的情况下，由于epoll需要很多回调，因此性能可能低于其它两者。</p>
</details>

<details>
<summary>什么是文件描述符？</summary>

<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p>
<p>内核通过文件描述符来访问文件。文件描述符指向一个文件。</p>
</details>

<h5 id="什么是水平触发？什么是边缘触发？"><a href="#什么是水平触发？什么是边缘触发？" class="headerlink" title="什么是水平触发？什么是边缘触发？"></a>什么是水平触发？什么是边缘触发？</h5><details>
<summary>展开</summary>

<ul>
<li>水平触发（LT，Level Trigger）模式下，只要一个文件描述符就绪，就会触发通知，如果用户程序没有一次性把数据读写完，下次还会通知；</li>
<li>边缘触发（ET，Edge Trigger）模式下，当描述符从未就绪变为就绪时通知一次，之后不会再通知，直到再次从未就绪变为就绪（缓冲区从不可读/写变为可读/写）。</li>
<li>区别：边缘触发效率更高，减少了被重复触发的次数，函数不会返回大量用户程序可能不需要的文件描述符。</li>
<li>为什么边缘触发一定要用非阻塞（non-block）IO：避免由于一个描述符的阻塞读/阻塞写操作让处理其它描述符的任务出现饥饿状态。</details>

</li>
</ul>
<h5 id="有哪些常见的IO模型？"><a href="#有哪些常见的IO模型？" class="headerlink" title="有哪些常见的IO模型？"></a>有哪些常见的IO模型？</h5><details>
<summary>展开</summary>

<ul>
<li>同步阻塞IO（Blocking IO）：用户线程发起IO读/写操作之后，线程阻塞，直到可以开始处理数据；对CPU资源的利用率不够；</li>
<li>同步非阻塞IO（Non-blocking IO）：发起IO请求之后可以立即返回，如果没有就绪的数据，需要不断地发起IO请求直到数据就绪；不断重复请求消耗了大量的CPU资源；</li>
<li>IO多路复用</li>
<li>异步IO（Asynchronous IO）：用户线程发出IO请求之后，继续执行，由内核进行数据的读取并放在用户指定的缓冲区内，在IO完成之后通知用户线程直接使用。</details>

</li>
</ul>
<h3 id="什么是用户态和内核态？"><a href="#什么是用户态和内核态？" class="headerlink" title="什么是用户态和内核态？"></a>什么是用户态和内核态？</h3><p>为了限制不同程序的访问能力，防止一些程序访问其它程序的内存数据，CPU划分了用户态和内核态两个权限等级。</p>
<ul>
<li>用户态只能受限地访问内存，且不允许访问外围设备，没有占用CPU的能力，CPU资源可以被其它程序获取；</li>
<li>内核态可以访问内存所有数据以及外围设备，也可以进行程序的切换。</li>
</ul>
<p>所有用户程序都运行在用户态，但有时需要进行一些内核态的操作，比如从硬盘或者键盘读数据，这时就需要进行系统调用，使用<strong>陷阱指令</strong>，CPU切换到内核态，执行相应的服务，再切换为用户态并返回系统调用的结果。</p>
<h5 id="为什么要分用户态和内核态？"><a href="#为什么要分用户态和内核态？" class="headerlink" title="为什么要分用户态和内核态？"></a>为什么要分用户态和内核态？</h5><details>
<summary>展开</summary>

<p>（我自己的见解：）</p>
<ul>
<li>安全性：防止用户程序恶意或者不小心破坏系统/内存/硬件资源；</li>
<li>封装性：用户程序不需要实现更加底层的代码；</li>
<li>利于调度：如果多个用户程序都在等待键盘输入，这时就需要进行调度；统一交给操作系统调度更加方便。</details>

</li>
</ul>
<h5 id="如何从用户态切换到内核态？"><a href="#如何从用户态切换到内核态？" class="headerlink" title="如何从用户态切换到内核态？"></a>如何从用户态切换到内核态？</h5><details>
<summary>展开</summary>

<ul>
<li>系统调用：比如读取命令行输入。本质上还是通过中断实现</li>
<li>用户程序发生异常时：比如缺页异常</li>
<li>外围设备的中断：外围设备完成用户请求的操作之后，会向CPU发出中断信号，这时CPU会转去处理对应的中断处理程序</details>

</li>
</ul>
<hr>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h3><p>在两个或者多个并发进程中，每个进程持有某种资源而又等待其它进程释放它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁(deadlock)。</p>
<h3 id="死锁产生的必要条件？"><a href="#死锁产生的必要条件？" class="headerlink" title="死锁产生的必要条件？"></a>死锁产生的必要条件？</h3><ul>
<li><strong>互斥</strong>：一个资源一次只能被一个进程使用；</li>
<li><strong>占有并等待</strong>：一个进程至少占有一个资源，并在等待另一个被其它进程占用的资源；</li>
<li><strong>非抢占</strong>：已经分配给一个进程的资源不能被强制性抢占，只能由进程完成任务之后自愿释放；</li>
<li><strong>循环等待</strong>：若干进程之间形成一种头尾相接的环形等待资源关系，该环路中的每个进程都在等待下一个进程所占有的资源。</li>
</ul>
<h3 id="死锁有哪些处理方法？"><a href="#死锁有哪些处理方法？" class="headerlink" title="死锁有哪些处理方法？"></a>死锁有哪些处理方法？</h3><details>
<summary>鸵鸟策略</summary>

<p>直接忽略死锁。因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p>
</details>

<details>
<summary>死锁预防</summary>

<p>基本思想是破坏形成死锁的四个必要条件：</p>
<ul>
<li>破坏互斥条件：允许某些资源同时被多个进程访问。但是有些资源本身并不具有这种属性，因此这种方案实用性有限；</li>
<li>破坏占有并等待条件：<ul>
<li>实行资源预先分配策略（当一个进程开始运行之前，必须一次性向系统申请它所需要的全部资源，否则不运行）；</li>
<li>或者只允许进程在没有占用资源的时候才能申请资源（申请资源前先释放占有的资源）；</li>
<li>缺点：很多时候无法预知一个进程所需的全部资源；同时，会降低资源利用率，降低系统的并发性；</li>
</ul>
</li>
<li>破坏非抢占条件：允许进程强行抢占被其它进程占有的资源。会降低系统性能；</li>
<li>破坏循环等待条件：对所有资源统一编号，所有进程对资源的请求必须按照序号递增的顺序提出，即只有占有了编号较小的资源才能申请编号较大的资源。这样避免了占有大号资源的进程去申请小号资源。</details>

</li>
</ul>
<details>
<summary>死锁避免</summary>

<p>动态地检测资源分配状态，以确保系统处于安全状态，只有处于安全状态时才会进行资源的分配。所谓安全状态是指：即使所有进程突然请求需要的所有资源，也能存在某种对进程的资源分配顺序，使得每一个进程运行完毕。</p>
<blockquote>
<p>银行家算法</p>
</blockquote>
</details>

<details>
<summary>死锁解除</summary>

<blockquote>
<p>如何检测死锁：检测有向图是否存在环；或者使用类似死锁避免的检测算法。</p>
</blockquote>
<p>死锁解除的方法：</p>
<ul>
<li>利用抢占：挂起某些进程，并抢占它的资源。但应防止某些进程被长时间挂起而处于饥饿状态；</li>
<li>利用回滚：让某些进程回退到足以解除死锁的地步，进程回退时自愿释放资源。要求系统保持进程的历史信息，设置还原点；</li>
<li>利用杀死进程：强制杀死某些进程直到死锁解除为止，可以按照优先级进行。</details>

</li>
</ul>
<hr>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="分页和分段有什么区别？"><a href="#分页和分段有什么区别？" class="headerlink" title="分页和分段有什么区别？"></a>分页和分段有什么区别？</h3><ul>
<li>页式存储：用户空间划分为大小相等的部分称为页（page），内存空间划分为同样大小的区域称为页框，分配时以页为单位，按进程需要的页数分配，逻辑上相邻的页物理上不一定相邻；</li>
<li>段式存储：用户进程地址空间按照自身逻辑关系划分为若干个段（segment）（如代码段，数据段，堆栈段），内存空间被动态划分为长度不同的区域，分配时以段为单位，每段在内存中占据连续空间，各段可以不相邻；</li>
<li>段页式存储：用户进程先按段划分，段内再按页划分，内存划分和分配按页。</li>
</ul>
<p>区别：</p>
<ul>
<li>目的不同：分页的目的是管理内存，用于虚拟内存以获得更大的地址空间；分段的目的是满足用户的需要，使程序和数据可以被划分为逻辑上独立的地址空间；</li>
<li>大小不同：段的大小不固定，由其所完成的功能决定；页的大小固定，由系统决定；</li>
<li>地址空间维度不同：分段是二维地址空间（段号+段内偏移），分页是一维地址空间（每个进程一个页表/多级页表，通过一个逻辑地址就能找到对应的物理地址）；</li>
<li>分段便于信息的保护和共享；分页的共享收到限制；</li>
<li>碎片：分段没有内碎片，但会产生外碎片；分页没有外碎片，但会产生内碎片（一个页填不满）</li>
</ul>
<h3 id="什么是虚拟内存？"><a href="#什么是虚拟内存？" class="headerlink" title="什么是虚拟内存？"></a>什么是虚拟内存？</h3><p>每个程序都拥有自己的地址空间，这个地址空间被分成大小相等的页，这些页被映射到物理内存；但不需要所有的页都在物理内存中，当程序引用到不在物理内存中的页时，由操作系统将缺失的部分装入物理内存。这样，对于程序来说，逻辑上似乎有很大的内存空间，只是实际上有一部分是存储在磁盘上，因此叫做虚拟内存。</p>
<p>虚拟内存的优点是让程序可以获得更多的可用内存。</p>
<h5 id="如何进行地址空间到物理内存的映射？"><a href="#如何进行地址空间到物理内存的映射？" class="headerlink" title="如何进行地址空间到物理内存的映射？"></a>如何进行地址空间到物理内存的映射？</h5><details>
<summary>展开</summary>

<p><strong>内存管理单元</strong>（MMU）管理着逻辑地址和物理地址的转换，其中的页表（Page table）存储着页（逻辑地址）和页框（物理内存空间）的映射表，页表中还包含包含有效位（是在内存还是磁盘）、访问位（是否被访问过）、修改位（内存中是否被修改过）、保护位（只读还是可读写）。逻辑地址：页号+页内地址（偏移）；每个进程一个页表，放在内存，页表起始地址在PCB/寄存器中。</p>
</details>

<h3 id="有哪些页面置换算法？"><a href="#有哪些页面置换算法？" class="headerlink" title="有哪些页面置换算法？"></a>有哪些页面置换算法？</h3><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘中来腾出空间。页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p>
<ul>
<li><strong>最佳页面置换算法</strong>OPT（Optimal replacement algorithm）：置换以后不需要或者最远的将来才需要的页面，是一种理论上的算法，是最优策略；</li>
<li><strong>先进先出</strong>FIFO：置换在内存中驻留时间最长的页面。缺点：有可能将那些经常被访问的页面也被换出，从而使缺页率升高；</li>
<li><strong>第二次机会算法</strong>SCR：按FIFO选择某一页面，若其访问位为1，给第二次机会，并将访问位置0；</li>
<li><strong>时钟算法</strong> Clock：SCR中需要将页面在链表中移动（第二次机会的时候要将这个页面从链表头移到链表尾），时钟算法使用环形链表，再使用一个指针指向最老的页面，避免了移动页面的开销；</li>
<li><strong>最近未使用算法</strong>NRU（Not Recently Used）：检查访问位R、修改位M，优先置换R=M=0，其次是（R=0, M=1）；</li>
<li><strong>最近最少使用算法</strong>LRU（Least Recently Used）：置换出未使用时间最长的一页；实现方式：维护时间戳，或者维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</li>
<li><strong>最不经常使用算法</strong>NFU：置换出访问次数最少的页面</li>
</ul>
<details>
<summary>局部性原理</summary>

<ul>
<li>时间上：最近被访问的页在不久的将来还会被访问；</li>
<li>空间上：内存中被访问的页周围的页也很可能被访问。</details>

</li>
</ul>
<details>
<summary>什么是颠簸现象</summary>

<p>颠簸本质上是指频繁的页调度行为。进程发生缺页中断时必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸。内存颠簸的解决策略包括：</p>
<ul>
<li>修改页面置换算法；</li>
<li>降低同时运行的程序的数量；</li>
<li>终止该进程或增加物理内存容量。</details>

</li>
</ul>
<h3 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h3><p>过程：磁头（找到对应的盘面）；磁道（一个盘面上的同心圆环，寻道时间）；扇区（旋转时间）。为减小寻道时间的调度算法：</p>
<ul>
<li>先来先服务</li>
<li>最短寻道时间优先</li>
<li>电梯算法：电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c1015f5ffa74">进程间通信IPC – 简书</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/justloveyou_/article/details/78304294">面试/笔试第二弹 —— 操作系统面试问题集锦 - CSDN博客</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000018970361">线程同步与并发 - - SegmentFault</a></li>
<li><a target="_blank" rel="noopener" href="http://baijiahao.baidu.com/s?id=1641172494287388070&wfr=spider&for=pc">彻底搞懂epoll高效运行的原理</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lirong21/p/4213028.html">用户态与内核态的切换</a></li>
</ul>
<h3 id="待完成"><a href="#待完成" class="headerlink" title="待完成"></a>待完成</h3><ul>
<li><input disabled="" type="checkbox"> IPC</li>
<li><input disabled="" type="checkbox"> 进程同步问题：生产者-消费者问题…</li>
<li><input disabled="" type="checkbox"> 银行家算法</li>
<li><input disabled="" type="checkbox"> 文件与文件系统、文件管理？<div>
<img src="_v_images/20191202162008435_14938.png" width=540px></img>
</div>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="next" title="计算机网络">
                <i class="fa fa-chevron-left"></i> 计算机网络
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/VastRock-Huang" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">进程和线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.1.1.</span> <span class="nav-text">进程和线程有什么区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E4%B8%80%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%E5%85%B1%E4%BA%AB%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">同一进程中的线程可以共享哪些数据？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%8B%AC%E5%8D%A0%E5%93%AA%E4%BA%9B%E8%B5%84%E6%BA%90%EF%BC%9F"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">线程独占哪些资源？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">1.1.2.</span> <span class="nav-text">进程间通信有哪些方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="nav-number">1.1.3.</span> <span class="nav-text">进程有哪几种状态？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">1.1.4.</span> <span class="nav-text">进程调度策略有哪些</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">1 批处理系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">2. 交互式系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E5%8F%AB%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8D%E8%BD%AC%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">什么叫优先级反转？如何解决？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="nav-number">1.1.5.</span> <span class="nav-text">什么是僵尸进程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="nav-number">1.1.6.</span> <span class="nav-text">什么是孤儿进程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E3%80%81%E5%B9%B6%E8%A1%8C%E3%80%81%E5%BC%82%E6%AD%A5"><span class="nav-number">1.1.7.</span> <span class="nav-text">并发、并行、异步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.8.</span> <span class="nav-text">进程同步问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90%E5%92%8C%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="nav-number">1.1.8.1.</span> <span class="nav-text">临界资源和临界区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="nav-number">1.1.8.2.</span> <span class="nav-text">进程的同步与互斥</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.8.3.</span> <span class="nav-text">生产者-消费者问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.8.4.</span> <span class="nav-text">读者-写者问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.8.5.</span> <span class="nav-text">哲学家就餐问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B-Monitor"><span class="nav-number">1.1.8.6.</span> <span class="nav-text">管程 Monitor</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">1.1.9.</span> <span class="nav-text">Linux线程同步有哪些方式？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%BA%92%E6%96%A5%E9%94%81-mutex"><span class="nav-number">1.1.9.1.</span> <span class="nav-text">1.互斥锁(mutex):</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F-cond"><span class="nav-number">1.1.9.2.</span> <span class="nav-text">2.条件变量(cond)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">1.1.9.3.</span> <span class="nav-text">3.读写锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">1.1.9.4.</span> <span class="nav-text">4.信号量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E7%A8%8B%EF%BC%9F"><span class="nav-number">1.1.10.</span> <span class="nav-text">什么是协程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E8%BF%9B%E8%A1%8C%E6%AF%94%E8%BE%83"><span class="nav-number">1.1.11.</span> <span class="nav-text">协程与线程进行比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%9F%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-number">1.1.12.</span> <span class="nav-text">什么是IO多路复用？怎么实现？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select-poll-epoll%E5%8F%8A%E5%85%B6%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.13.</span> <span class="nav-text">select&#x2F;poll&#x2F;epoll及其区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#select"><span class="nav-number">1.1.13.1.</span> <span class="nav-text">select</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#poll"><span class="nav-number">1.1.13.2.</span> <span class="nav-text">poll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll"><span class="nav-number">1.1.13.3.</span> <span class="nav-text">epoll</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91%EF%BC%9F"><span class="nav-number">1.1.13.3.1.</span> <span class="nav-text">什么是水平触发？什么是边缘触发？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84IO%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="nav-number">1.1.13.3.2.</span> <span class="nav-text">有哪些常见的IO模型？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%EF%BC%9F"><span class="nav-number">1.1.14.</span> <span class="nav-text">什么是用户态和内核态？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%EF%BC%9F"><span class="nav-number">1.1.14.0.1.</span> <span class="nav-text">为什么要分用户态和内核态？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BB%8E%E7%94%A8%E6%88%B7%E6%80%81%E5%88%87%E6%8D%A2%E5%88%B0%E5%86%85%E6%A0%B8%E6%80%81%EF%BC%9F"><span class="nav-number">1.1.14.0.2.</span> <span class="nav-text">如何从用户态切换到内核态？</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">1.2.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="nav-number">1.2.1.</span> <span class="nav-text">什么是死锁？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%EF%BC%9F"><span class="nav-number">1.2.2.</span> <span class="nav-text">死锁产生的必要条件？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">1.2.3.</span> <span class="nav-text">死锁有哪些处理方法？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">1.3.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.3.1.</span> <span class="nav-text">分页和分段有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%9F"><span class="nav-number">1.3.2.</span> <span class="nav-text">什么是虚拟内存？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%B0%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%E6%98%A0%E5%B0%84%EF%BC%9F"><span class="nav-number">1.3.2.0.1.</span> <span class="nav-text">如何进行地址空间到物理内存的映射？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="nav-number">1.3.3.</span> <span class="nav-text">有哪些页面置换算法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6"><span class="nav-number">1.3.4.</span> <span class="nav-text">磁盘调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">1.3.5.</span> <span class="nav-text">参考</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%85%E5%AE%8C%E6%88%90"><span class="nav-number">1.3.6.</span> <span class="nav-text">待完成</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">VastRock-Huang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
