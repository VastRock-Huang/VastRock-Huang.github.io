<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="计算机网络 传输层：TCP和UDP什么是三次握手 (three-way handshake)?![TCP状态图](https:&#x2F;&#x2F;www.hoohack.me&#x2F;assets&#x2F;images&#x2F;2018&#x2F;09&#x2F;tcp-classic.png &#x3D;550x)  展开  第一次握手 Client(主动打开)将SYN(同步比特)置1,随机产生一个初始序列号(ISN) seq&#x3D;J发送给Server, 无应用层数据">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="http://example.com/2021/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="Abyss">
<meta property="og:description" content="计算机网络 传输层：TCP和UDP什么是三次握手 (three-way handshake)?![TCP状态图](https:&#x2F;&#x2F;www.hoohack.me&#x2F;assets&#x2F;images&#x2F;2018&#x2F;09&#x2F;tcp-classic.png &#x3D;550x)  展开  第一次握手 Client(主动打开)将SYN(同步比特)置1,随机产生一个初始序列号(ISN) seq&#x3D;J发送给Server, 无应用层数据">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/2021/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/_v_images/20191129101827556_21212.png">
<meta property="og:image" content="http://example.com/2021/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/_v_images/20191129112652915_15481.png">
<meta property="og:image" content="http://example.com/2021/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/_v_images/20191129153624025_28293.png">
<meta property="og:image" content="http://example.com/2021/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/_v_images/20191129155345024_11142.png">
<meta property="og:image" content="http://example.com/2021/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/_v_images/20191129161026032_32431.png">
<meta property="article:published_time" content="2021-03-02T16:17:36.000Z">
<meta property="article:modified_time" content="2021-03-02T16:18:36.127Z">
<meta property="article:author" content="VastRock-Huang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/_v_images/20191129101827556_21212.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/2021/03/03/计算机网络/"/>





  <title>计算机网络 | Abyss</title>
  








<meta name="generator" content="Hexo 5.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Abyss</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Abyss">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">计算机网络</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-03T00:17:36+08:00">
                2021-03-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><hr>
<h2 id="传输层：TCP和UDP"><a href="#传输层：TCP和UDP" class="headerlink" title="传输层：TCP和UDP"></a>传输层：TCP和UDP</h2><h3 id="什么是三次握手-three-way-handshake"><a href="#什么是三次握手-three-way-handshake" class="headerlink" title="什么是三次握手 (three-way handshake)?"></a>什么是三次握手 (three-way handshake)?</h3><p>![TCP状态图](<a target="_blank" rel="noopener" href="https://www.hoohack.me/assets/images/2018/09/tcp-classic.png">https://www.hoohack.me/assets/images/2018/09/tcp-classic.png</a> =550x)<br><img src="_v_images/20191129101827556_21212.png" alt="三次握手"></p>
<details>
<summary>展开</summary>

<h4 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h4><ul>
<li>Client(主动打开)将<strong>SYN(同步比特)置1</strong>,<strong>随机产生一个初始序列号(ISN) seq=J</strong>发送给Server,</li>
<li><strong>无应用层数据</strong>, 客户端进入SYN_SENT状态; <h4 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h4></li>
<li>Server收到Client的SYN=1的报文段之后, 知道客户端请求建立连接, </li>
<li>将自己的<strong>SYN置1, ACK(确认比特)置1, 产生一个ack(确认号)=seq(序列号)+1=J+1</strong>, 并<strong>随机产生一个自己的初始序列号seq=K</strong>, 发送给客户端; </li>
<li>服务端进入SYN_RCVD状态</li>
<li>发送后服务端分配资源, 直到超时才释放资源<h4 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h4></li>
<li>客户端检查收到报文段的ack(确认号)是否为序列号J+1, ACK是否为1.</li>
<li>检查正确之后分配资源. 将自己的<strong>ACK置为1, 产生一个确认号ack=K+1</strong>, 发送给服务器; 客户端进入ESTABLISHED状态; </li>
<li>第三次握手客户端发送的报文段可以携带数据, 也可不带</li>
<li>服务器检查ACK为1和ack为序列号K+1之后, 也进入ESTABLISHED状态; 完成三次握手, 连接建立. </details>

</li>
</ul>
<h3 id="TCP建立连接可以两次握手吗-为什么"><a href="#TCP建立连接可以两次握手吗-为什么" class="headerlink" title="TCP建立连接可以两次握手吗? 为什么?"></a>TCP建立连接可以两次握手吗? 为什么?</h3><details>
<summary>展开</summary>

<p><strong>不可以</strong>. </p>
<ul>
<li>TCP是双向通信, 两次握手只能确保一个方向建立连接, <strong>Server无法确认Client是否收到第二次握手的报文段</strong>, 也<strong>无法保证Client和Server之间成功互换初始序列号</strong>.</li>
<li>可能会出现<strong>已失效的连接请求报文段又传到了服务器端</strong>. client 发出的第一个连接请求报文段并没有丢失, 而是在某个网络结点长时间的滞留了, 以致延误到连接释放以后的某个时间才到达 server. 本来这是一个早已失效的报文段(<strong>客户端连接释放后客户端才收到已经失效的连接请求</strong>). 但server 收到此失效的连接请求报文段后, 就误认为是 client 再次发出的一个新的连接请求. 于是<strong>Server就向 client 发出确认报文段, 同意建立连接</strong>. 假设<strong>不采用 “三次握手”, 那么只要 server 发出确认, 新的连接就建立了</strong>. 由于现在<strong>client 并没有发出建立连接的请求, 因此不会理睬 server 的确认, 也不会向 server 发送数据. 但 server 却以为新的运输连接已经建立, 并一直等待 client 发来数据</strong>. 这样, server 的很多资源就白白浪费掉了. 采用 “三次握手” 的办法可以防止上述现象发生. 例如刚才那种情况, client 不会向 server 的确认发出确认. server 由于收不到确认, 就知道 client 并没有要求建立连接. </li>
<li>如果客户端的 SYN 阻塞了, 重复发送多次 SYN 报文, 那么<strong>服务器在收到请求后就会建立多个冗余的无效链接, 造成不必要的资源浪费</strong>.</li>
</ul>
</details>

<h3 id="可以采用四次握手吗-为什么"><a href="#可以采用四次握手吗-为什么" class="headerlink" title="可以采用四次握手吗? 为什么?"></a>可以采用四次握手吗? 为什么?</h3><details>
<summary>展开</summary>

<p><strong>可以. 但是会降低传输的效率</strong>.<br>四次握手是指：<strong>第二次握手：Server只发送ACK(确认比特)和acknowledge number(确认序列号); 而Server的SYN和初始序列号(seq=k)在第三次握手时发送; 原来协议中的第三次握手变为第四次握手</strong>. 出于优化目的, 四次握手中的二、三可以合并. </p>
</details>

<h3 id="第三次握手中-如果客户端的ACK未送达服务器-会怎样"><a href="#第三次握手中-如果客户端的ACK未送达服务器-会怎样" class="headerlink" title="第三次握手中, 如果客户端的ACK未送达服务器, 会怎样?"></a>第三次握手中, 如果客户端的ACK未送达服务器, 会怎样?</h3><details>
<summary>展开</summary>

<ul>
<li>Server端：  </li>
</ul>
<ol>
<li>由于Server没有收到ACK确认, 因此会<strong>重发之前的SYN+ACK(第二次握手的报文段), 默认重发五次, 之后自动关闭连接进入CLOSED状态</strong>关闭连接, Client收到后会重新传ACK给Server. </li>
<li>在Server进行超时重发的过程中, 如果服务器收到客户端第三次挥手报文, 进入establish 状态建立连接.</li>
<li><strong>Server此时为SYN_RCVD状态</strong>,而不是ESTABLISHED状态, 若<strong>收到Client发送的数据, 服务器会以RST包应答</strong>(RST=1复位比特, 需要释放连接重新建立). </li>
</ol>
<ul>
<li>Client端:<br>由于客户端在收到第二次握手的报文后就进入了ESTABLISH 状态, 认为连接已经建立, 因此发送第三次握手的报文后就可以向服务端发送数据.<br>如果第三次握手中的ACK包丢失的情况下, Client 向 server端发送数据, Server端将以RST包响应, 客户端Client便能感知到Server的错误. </details>

</li>
</ul>
<h3 id="如果已经建立了连接-但客户端出现了故障怎么办"><a href="#如果已经建立了连接-但客户端出现了故障怎么办" class="headerlink" title="如果已经建立了连接, 但客户端出现了故障怎么办?"></a>如果已经建立了连接, 但客户端出现了故障怎么办?</h3><details>
<summary>展开</summary>

<p>服务器<strong>每收到一次客户端的请求后都会重新复位一个保活计时器</strong>, 时间通常是设置为2小时, 若两小时还没有收到客户端的任何数据, 服务器就会<strong>发送一个探测报文段, 以后每隔75秒钟发送一次. 若一连发送10个</strong>探测报文仍然没反应, 服务器就认为客户端出了故障, 接着就关闭连接. </p>
</details>

<h3 id="初始序列号是什么"><a href="#初始序列号是什么" class="headerlink" title="初始序列号是什么?"></a>初始序列号是什么?</h3><details>
<summary>展开</summary>

<ul>
<li>TCP连接的一方A, <strong>随机选择一个32位的序列号</strong>(Sequence Number)作为发送数据的初始序列号(Initial Sequence Number, ISN), 比如为1000, </li>
<li>以该序列号为原点, 对要传送的数据(每一个字节)进行编号：1001、1002… </li>
<li>三次握手时, 把这个初始序列号传送给另一方B(第一次握手客户端-&gt;服务端, 第二次握手服务端-&gt;客户端)</li>
<li>以便在传输数据时, B可以确认什么样的数据编号是合法的; 同时在进行数据传输时, A还可以确认B收到的每一个字节, 如果A收到了B的确认编号(acknowledge number)是2001, 就说明编号为1001-2000的数据已经被B成功接受. </details>

</li>
</ul>
<hr>
<h3 id="什么是四次挥手"><a href="#什么是四次挥手" class="headerlink" title="什么是四次挥手?"></a>什么是四次挥手?</h3><p><img src="_v_images/20191129112652915_15481.png" alt="四次挥手"></p>
<details>
<summary>展开</summary>

<h4 id="第一次挥手"><a href="#第一次挥手" class="headerlink" title="第一次挥手"></a>第一次挥手</h4><ul>
<li>Client将<strong>FIN(终止比特)置为1</strong>, 发送一个序列号seq=M 给Server; </li>
<li>进入FIN_WAIT_1状态; <h4 id="第二次挥手"><a href="#第二次挥手" class="headerlink" title="第二次挥手"></a>第二次挥手</h4></li>
<li>Server收到FIN之后, 发送一个<strong>ACK=1, ack(确认号)=收到的序列号M+1</strong>的报文段; 进入CLOSE_WAIT状态. </li>
<li>此时客户端已经没有要发送的数据了, 但仍可以接受服务器发来的数据</li>
<li>客户端收到服务端第二次挥手的报文段后进入FIN_WAIT_2状态<h4 id="第三次挥手"><a href="#第三次挥手" class="headerlink" title="第三次挥手"></a>第三次挥手</h4></li>
<li>Server将<strong>FIN置1, 发送一个序列号seq=N</strong>给Client; </li>
<li>服务端进入LAST_ACK状态; <h4 id="第四次挥手"><a href="#第四次挥手" class="headerlink" title="第四次挥手"></a>第四次挥手</h4></li>
<li>Client收到服务器的FIN后, 进入TIME_WAIT状态; </li>
<li>接着将<strong>ACK置1, 发送一个ack=序列号N+1</strong>给服务器; </li>
<li>服务器收到后, 确认ack后, 变为CLOSED状态, 不再向客户端发送数据. </li>
<li>客户端<strong>等待2×MSL(最大报文生存期)时间后</strong>, 也进入CLOSED状态. 完成四次挥手. </details>

</li>
</ul>
<h3 id="为什么不能把服务器发送的ACK和FIN合并起来-变成三次挥手-CLOSE-WAIT状态意义是什么"><a href="#为什么不能把服务器发送的ACK和FIN合并起来-变成三次挥手-CLOSE-WAIT状态意义是什么" class="headerlink" title="为什么不能把服务器发送的ACK和FIN合并起来, 变成三次挥手(CLOSE_WAIT状态意义是什么)?"></a>为什么不能把服务器发送的ACK和FIN合并起来, 变成三次挥手(CLOSE_WAIT状态意义是什么)?</h3><details>
<summary>展开</summary>

<ul>
<li>因为服务器收到客户端断开连接的请求时, <strong>服务端可能还有一些数据没有发完</strong>, 这时先回复ACK, 表示接收到了断开连接的请求. </li>
<li><strong>等到数据发完之后再发FIN</strong>, 断开服务器到客户端的数据传送. </details>

</li>
</ul>
<h3 id="如果第二次挥手时服务器的ACK没有送达客户端-会怎样"><a href="#如果第二次挥手时服务器的ACK没有送达客户端-会怎样" class="headerlink" title="如果第二次挥手时服务器的ACK没有送达客户端, 会怎样?"></a>如果第二次挥手时服务器的ACK没有送达客户端, 会怎样?</h3><details>
<summary>展开</summary>

<p><strong>客户端</strong>没有收到ACK确认, 会<strong>重新发送FIN(断开连接)请求</strong>. </p>
</details>

<h3 id="客户端TIME-WAIT状态的意义是什么"><a href="#客户端TIME-WAIT状态的意义是什么" class="headerlink" title="客户端TIME_WAIT状态的意义是什么?"></a>客户端TIME_WAIT状态的意义是什么?</h3><details>
<summary>展开</summary>

<ul>
<li><strong>实现TCP全双工连接的可靠释放</strong>: <ul>
<li>第四次挥手时, <strong>客户端发送给服务器的ACK(第四次挥手)有可能丢失</strong>, TIME_WAIT状态就是<strong>用来重发可能丢失的ACK报文</strong>. </li>
<li>如果Server没有收到ACK(第四次挥手报文段), 就会重发FIN, 如果Client在2×MSL(最大报文段生存期)的时间内收到了FIN, 就会<strong>重新发送ACK并再次等待2MSL, 防止Server没有收到ACK而不断重发FIN</strong>. </li>
<li>如果直到2MSL, Client都没有再次收到FIN, 那么Client推断ACK已经被成功接收, 则结束TCP连接. </li>
</ul>
</li>
<li><strong>保证迟来的TCP报文段有足够的时间被识别并丢弃</strong>.<ul>
<li>若一条连接先关闭关闭紧接着用相同的四元组建立一条新连接, 则旧连接中延迟到达的TCP报文段可能会作为新连接的数据.</li>
<li>TIME_WAIT阶段TCP<strong>不能再建立一条相同的连接</strong>, 能保证所有旧连接的旧数据能够被丢弃</li>
</ul>
</li>
<li>MSL(Maximum Segment Lifetime): 最大报文段生存期, 指一个片段在网络中最大的存活时间, 2MSL就是一个发送和一个回复所需的最大时间. <ul>
<li>一个MSL是确保主动关闭方最后的ACK能够到达对端。</li>
<li>一个MSL是确保被动关闭方重发的FIN能够被主动关闭方收到。</li>
</ul>
</li>
</ul>
</details>

<h3 id="TCP如何实现流量控制"><a href="#TCP如何实现流量控制" class="headerlink" title="TCP如何实现流量控制?"></a>TCP如何实现流量控制?</h3><p>![滑动窗口](_v_images/20191129145400104_2106.png =600x)</p>
<details>
<summary>展开</summary>

<ul>
<li>使用<strong>滑动窗口协议实现流量控制</strong>. 防止发送方发送速率太快, 接收方缓存区不够导致溢出. </li>
<li>接收方会维护一个接收窗口 receiver window(窗口大小单位是字节), 接受窗口的大小是根据自己的资源情况动态调整的.</li>
<li>RcvWindows = RcvBuffer - (LastByteRcvd - LastByteRead) = 接收缓存大小 - (最后收到字节的编号 - 最后读取字节的编号) = 接收缓存大小 - 缓存中的TCP数据</li>
<li>在返回ACK时<strong>将接受窗口大小放在TCP报文中的窗口字段</strong>告知发送方. <strong>发送窗口的大小不能超过接受窗口的大小</strong>, 只有当发送方发送并收到确认之后, 才能将发送窗口右移. </li>
<li><strong>发送窗口的上限为接受窗口和拥塞窗口中的较小值</strong>. 接受窗口表明了接收方的接收能力, 拥塞窗口表明了网络的传送能力. </details>

</li>
</ul>
<h3 id="什么是零窗口-接收窗口为0时会怎样"><a href="#什么是零窗口-接收窗口为0时会怎样" class="headerlink" title="什么是零窗口(接收窗口为0时会怎样)?"></a>什么是零窗口(接收窗口为0时会怎样)?</h3><details>
<summary>展开</summary>

<ul>
<li>如果接收方没有能力接收数据, 就会将接收窗口设置为0.</li>
<li>这时发送方必须暂停发送数据, 但是会<strong>启动一个持续计时器</strong>(persistence timer), 到期后发送一个<strong>大小为1字节的探测数据包</strong>, 以查看接收窗口状态. 如果接收方能够接收数据, 就会<strong>在返回的报文中更新接收窗口大小</strong>, 恢复数据传送. </details>

</li>
</ul>
<h3 id="TCP的拥塞控制是怎么实现的"><a href="#TCP的拥塞控制是怎么实现的" class="headerlink" title="TCP的拥塞控制是怎么实现的?"></a>TCP的拥塞控制是怎么实现的?</h3><p><img src="_v_images/20191129153624025_28293.png" alt="拥塞控制"></p>
<details>
<summary>展开</summary>

<ul>
<li>拥塞控制主要由四个算法组成：<strong>慢启动(Slow Start)、拥塞避免(Congestion voidance)、快速重传 (Fast Retransmit)、快速恢复(Fast Recovery)</strong></li>
</ul>
<ol>
<li>慢启动：刚开始发送数据时, 先把<strong>拥塞窗口(congestion window)设置为一个MSS</strong>(最大报文段长度)的数值, <strong>每收到一个新的确认后, 就把拥塞窗口加1个MSS</strong>. 这样每经过一个传输轮次(或者说是<strong>每经过一个往返时间</strong>RTT), <strong>拥塞窗口的大小就会加倍</strong>. (成指数速度增加发送速率).</li>
</ol>
<p><img src="_v_images/20191129155345024_11142.png" alt="slow start"></p>
<ol start="2">
<li><p>拥塞避免：当<strong>拥塞窗口的大小达到慢开始门限</strong>(slow start threshold)时, 开始执行拥塞避免算法, 拥塞窗口大小不再指数增加, 而是线性增加, 即<strong>每经过一个传输轮次只增加1MSS</strong>.  </p>
<blockquote>
<p>无论在慢启动阶段还是在拥塞避免阶段, 只要发送方判断网络出现拥塞, 对于超时事件,慢开始门限ssthresh设置为出现拥塞时的发送方拥塞窗口值的一半(但不能小于2),  拥塞窗口cwnd重新设置为1, 执行慢启动算法. (若不使用快速重传 TCP Tahoe版本, 对于三个重复ACK也是这样处理)</p>
</blockquote>
</li>
<li><p>快速重传：快重传要求接收方在收到一个<strong>失序的报文段后就立即发出重复确认</strong>(为的是使发送方及早知道有报文段没有到达对方)而不要等到自己发送数据时捎带确认. 快重传算法规定, 发送方只要一连<strong>收到三个重复确认</strong>就应当<strong>立即重传对方尚未收到的报文段</strong>, 而不必继续等待设置的重传计时器时间到期.  </p>
</li>
</ol>
<p><img src="_v_images/20191129161026032_32431.png" alt="快重传"></p>
<ol start="4">
<li>快速恢复：当发送方连续<strong>收到三个重复确认时, 就把慢开始门限ssthresh为原窗口大小的一半</strong>, 然后<strong>执行拥塞避免算法(线性增大拥塞窗口)</strong>. 不执行慢开始算法的原因：因为如果网络出现拥塞的话就不会收到好几个重复的确认, 所以发送方认为现在网络可能没有出现拥塞. <strong>拥塞窗口cwnd = ssthresh(减半后) + 3MSS</strong>. 这样做的理由是：既然发送方收到三个重复的确认, 就表明有三个分组已经离开了网络. 这三个分组不再消耗网络的资源而是停留在接收方的缓存中. 可见现在网络中减少了三个分组. 因此可以适当把拥塞窗口扩大些. </details>

</li>
</ol>
<h3 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h3><ol>
<li>TCP是面向连接的, UDP是无连接的; <details>
<summary>连接与无连接</summary>

</li>
</ol>
<p>TCP需要建立连接, 维护连接和释放连接. 需要<strong>维护分组之间的状态信息</strong>(如发送端记录数据发送时间, 通过序列号确认号来判断数据发送与确认情况)以保证数据传输的可靠有序<br>UDP发送数据之前不需要建立连接, 每个<strong>分组的处理都彼此独立</strong></p>
</details>

<ol start="2">
<li>TCP是可靠的, UDP不可靠; <details>
<summary>什么是可靠/不可靠? </summary></li>
</ol>
<ul>
<li>可靠: <ul>
<li>通过 TCP 连接传输的数据无差错, 不丢失, 按顺序到达. </li>
<li>TCP 报文头里面的序号能使 TCP 的数据按序到达</li>
<li>报文头里面的确认序号能保证不丢包, 累计确认及超时重传机制</li>
</ul>
</li>
<li>不可靠: UDP接收方收到报文后, 不需要给出任何确认</details>
</li>
</ul>
<ol start="3">
<li><p>TCP只支持点对点通信, 全双工; UDP支持一对一(单播)、一对多(广播)、多对一、多对多(多播); </p>
</li>
<li><p>TCP是面向字节流的, UDP是面向报文的; </p>
<details>
<summary>面向字节流/报文什么意思? </summary>
</li>
</ol>
<ul>
<li>面向字节流是指发送数据时以字节为单位. 如果发送的字节数太长, 会被拆分成多个TCP的数据包发出; 如果发送的字节数太短, 就会先在缓冲区里等待, 等到缓冲区长度合适, 或者其他合适的时机发送出去</li>
<li>面向报文是指 发送方的UDP对应用程序交下来的报文, 在添加首部后就向下交付IP层. UDP<strong>对应用层交下来的报文, 既不合并, 也不拆分</strong>.</details>
</li>
</ul>
<ol start="5">
<li>UDP能够明确区分两个数据包, 避免粘包问题; 而TCP存在粘包问题.<details>
<summary>粘包</summary></li>
</ol>
<ul>
<li>粘包问题中的”包”, 是指的应用层的数据包; </li>
<li>在TCP的协议头中, 没有”报文长度”字段, 但是有一个序号字段; </li>
<li>对于传输层, TCP报文按照序号排好序放在缓冲区中; </li>
<li>对于应用层, 收到的只是一串连续的字节数据. <strong>无法得知从哪个部分开始到哪个部分是一个完整的应用层数据包</strong>.</details>
</li>
</ul>
<ol start="6">
<li>TCP有拥塞控制机制和流量控制, UDP没有. UDP仅提供了运输层最基本的多路分级/多路复用, 和差错检测的功能. 网络出现的拥塞不会使源主机的发送速率降低, 这对某些实时应用是很重要的, 比如媒体通信, 游戏; </li>
<li>TCP首部开销(20字节)比UDP首部开销(8字节)要大</li>
<li>TCP的主机需要维持复杂的连接状态表, UDP 的主机不需要.</li>
</ol>
<h3 id="什么时候选择TCP-什么时候选UDP"><a href="#什么时候选择TCP-什么时候选UDP" class="headerlink" title="什么时候选择TCP, 什么时候选UDP?"></a>什么时候选择TCP, 什么时候选UDP?</h3><details>
<summary>展开</summary>

<ul>
<li><p>对某些<strong>实时性要求比较高</strong>的情况,选择<strong>UDP</strong>, 比如游戏, 媒体通信, 实时视频流(直播), 即使<strong>出现传输错误也可以容忍</strong>; </p>
</li>
<li><p>对于<strong>大量连接, 长连接以及大量传输数据, 优先考虑UDP</strong>(可靠传输).</p>
</li>
<li><p>对于<strong>有限连接(连接数较少)且为短连接时有限考虑TCP</strong>.</p>
</li>
<li><p>对于<strong>要求传输的内容可靠, 不出现丢失</strong>的情况, 如互联网HTTP, 文件传输FTP, 电子邮件SMTP等</p>
</li>
<li><p>如果数据要求完整,不允许任何错误发生, 应用层开放的协议, 例如http, ftp: 建议选择tcp, 几乎是唯一选择.</p>
</li>
<li><p>大量连接:</p>
<ul>
<li>长连接 :<ul>
<li>少量数据传输: 优先考虑udp可靠传输 , tcp建议在20000连接以下(连接数较少)使用.</li>
<li>大流量数据传输: 优先使用udp可靠传输, 只有在10000连接以下(连接数较少)可以考虑tcp </li>
</ul>
</li>
<li>短连接:<ul>
<li>少量数据传输: 建议使用udp标准模式, 加入序列号; 如果连接上限不超2万(连接数较少),可以考虑tcp</li>
</ul>
</li>
<li>大流量数据传输: 10000连接以下考虑tcp; 其他情况使用udp可靠传输</li>
<li>PS: 在遇到<strong>海量连接的情况下,建议优先考虑udp可靠传输</strong>, 使用tcp,由于tcp/ip栈的链表实现的影响,连接越多,性能下降越快,而udp可以实现队列,是一条平滑的直线,几乎没有性能影响.</li>
</ul>
</li>
<li><p>有限连接: 连接数通常小于2000 , 一般每服务器为几百到1000左右</p>
<ul>
<li>长连接: 除非有数据的实时性要求,优先考虑tcp,否则使用udp可靠传输.        </li>
<li><strong>短连接: 优先考虑tcp</strong>. 在有限连接的情况下,使用tcp可以减少代码的复杂性, 增加广泛的移植性, 并且不需要考虑性能问题.  </li>
</ul>
</li>
<li><p>允许丢包,甚至可以乱序</p>
<ul>
<li>对实时性要求比较高, 例如voip , 那么udp是最优选择.</li>
<li>部分数据允许丢包,部分数据要求完整,部分有实时性要求,通常这样的需求是出现在游戏里, 这时候, 基于udp协议改造的udp多路可靠传输(同时支持不可靠模式), 基本是唯一能满足的, 当然也可以使用tcp来传输要求完整的数据,但是通常不建议, 因为同时使用tcp和udp传输数据, 会导致代码臃肿复杂度增加, udp可靠传输完全可以替代tcp.</li>
<li>部分数据优先传输, 部分可丢弃数据在规定时效内传输, 这通常是实时视频流, 在有限连接模式下,可以考虑tcp+udp , 但是通常, 可靠udp传输是最好的选择.  </li>
</ul>
</li>
</ul>
</details>

<h3 id="HTTP可以使用UDP吗"><a href="#HTTP可以使用UDP吗" class="headerlink" title="HTTP可以使用UDP吗?"></a>HTTP可以使用UDP吗?</h3><details>
<summary>展开</summary>

<p>可以. </p>
<ul>
<li>HTTP/1和HTTP/2是基于TCP协议.</li>
<li>HTTP/3是基于传输层协议QUIC, 而QUIC就是基于UDP协议的.</li>
</ul>
</details>


<h3 id="TCP如何保证传输的可靠性"><a href="#TCP如何保证传输的可靠性" class="headerlink" title="TCP如何保证传输的可靠性"></a>TCP如何保证传输的可靠性</h3><details>
<summary>展开</summary>

<ol>
<li>数据包<strong>校验</strong></li>
<li>对<strong>失序数据包重新排序</strong>(TCP报文具有序列号)</li>
<li><strong>丢弃重复</strong>数据</li>
<li><strong>应答机制</strong>: 接收方收到数据之后, 会发送一个确认(通常延迟几分之一秒)</li>
<li><strong>超时重传</strong>: 发送方发出数据之后, 启动一个定时器, 超时未收到接收方的确认, 则重新发送这个数据; </li>
<li><strong>流量控制</strong>: 确保接收端能够接收发送方的数据而不会缓冲区溢出</li>
<li>TCP面向连接, 维护了各种状态(SYN_SENT, …, ESTABLISH, .. CLOSE)以保证收发双方能够正确处理数据包</details>

</li>
</ol>
<h2 id="应用层：HTTP和HTTPS"><a href="#应用层：HTTP和HTTPS" class="headerlink" title="应用层：HTTP和HTTPS"></a>应用层：HTTP和HTTPS</h2><h3 id="HTTP和HTTPS有什么区别"><a href="#HTTP和HTTPS有什么区别" class="headerlink" title="HTTP和HTTPS有什么区别?"></a>HTTP和HTTPS有什么区别?</h3><details>
<summary>展开</summary>

<ol>
<li><strong>端口不同</strong>：HTTP使用的是80端口, HTTPS使用443端口; </li>
<li>HTTP(超文本传输协议)信息是<strong>明文传输</strong>; HTTPS运行在SSL(Secure Socket Layer)/TLS(Transport Layer Security 安全传输层协议, 相当于SSL新版本)之上, 添加了<strong>加密和认证机制</strong>, 更加安全, 但由于加密解密会带来更大的CPU和内存开销; </li>
<li><strong>HTTPS通信需要证书</strong>, 一般需要向证书颁发机构(CA)购买</details>

</li>
</ol>
<h3 id="HTTPS的连接过程"><a href="#HTTPS的连接过程" class="headerlink" title="HTTPS的连接过程?"></a>HTTPS的连接过程?</h3><p>![https时序图](_v_images/20210223233633909_8123.jpg =530x)</p>
<details>
<summary>展开</summary>

<ol>
<li>客户端向服务器发送请求, 同时<strong>发送客户端支持的一套加密规则</strong>(包括对称加密、非对称加密、摘要算法); </li>
<li>服务器从中选出一组加密算法与HASH算法(若没有符合的算法则断开连接), 并<strong>将自己的身份信息以证书的形式发回给客户端浏览器</strong>. 证书里面包含了网站地址, <strong>加密公钥</strong>(用于非对称加密), 以及<strong>证书的颁发机构</strong>等信息(证书中的私钥只能用于服务器端进行解密); </li>
<li>客户端<strong>验证服务器的合法性</strong>, 包括：证书是否过期, CA 是否可靠, 发行者证书的公钥能否正确解开服务器证书的”发行者的数字签名”, 服务器证书上的域名是否和服务器的实际域名相匹配. 若证书无效则停止HTTPS请求.</li>
<li>如果证书受信任, 或者用户接收了不受信任的证书, 浏览器会生成一个<strong>用于对称算法的随机密钥</strong>, 并<strong>用服务器提供的公钥加密</strong>(采用非对称算法对密钥加密).</li>
<li>浏览器生成握手信息, 并使用Hash算法对握手消息进行<strong>摘要</strong>计算, 并对握手信息和摘要使用之前产生的对称密钥加密; 将加密后的随机密钥和握手信息及摘要一起发送给服务器; </li>
<li>服务器使用自己的私钥解密, 得到对称加密的密钥, 用这个密钥解密出握手信息和Hash摘要值, 并对握手信息进行摘要与接收到的握手消息比对是否一致; 如果一致(防篡改), <strong>服务器使用对称加密的密钥加密握手消息及摘要发给客户端浏览器</strong>; </li>
<li>浏览器<strong>解密并验证摘要</strong>, 若一致, 则握手结束. 之后的<strong>数据传送都使用对称加密的密钥</strong>进行加密<br>总结：非对称加密算法用于在握手过程中加密生成的密码; 对称加密算法用于对真正传输的数据进行加密; HASH算法用于验证数据的完整性. </details>

</li>
</ol>
<h3 id="如何确定网址用HTTP还是HTTPS"><a href="#如何确定网址用HTTP还是HTTPS" class="headerlink" title="如何确定网址用HTTP还是HTTPS?"></a>如何确定网址用HTTP还是HTTPS?</h3><details>
<summary>展开</summary>

<ol>
<li>浏览器默认使用 HTTP 去访问网址</li>
<li>服务器响应使用HTTP状态码<strong>302或301进行重定向</strong>, 服务器把所有的HTTP流量跳转到HTTPS(但这样需要每次访问都重定向需要访问服务器两次, 且中间人可能在第一次访问站点时劫持用户).<br>![HSTS时序图](_v_images/20210224001202088_19966.jpg =540x)</li>
<li>(为解决上述问题)引入<strong>HSTS</strong>(HTTP Strict-Transport-Security, HTTP严格传输安全协议), 用户浏览器在访问站点的时候强制使用HTTPS. 具体来讲, 使用HTTP访问服务器时, 服务器给浏览器的<strong>响应中增加<code>Strict-Transport-Security</code>这个HTTP字段, 强制浏览器在一段时间内访问该站点时使用HTTPS</strong>.</li>
<li>使用HSTS时, 当浏览器没有当前网站的HSTS信息的时候, 或者第一次访问网站的时候, 依然需要一次明文的HTTP请求和重定向才能切换到HTTPS, 以及刷新HSTS信息. HSTS应对上述问题, 在浏览器里<strong>内置一个列表HTST Preload List</strong>, 在这个列表里的域名, 无论何时、何种情况, 浏览器都只使用HTTPS发起连接. 这个列表由Google Chromium维护(服务器需要向其提交申请才能加入列表).<ul>
<li>Ref: <a target="_blank" rel="noopener" href="https://help.trustasia.com/what-is-hsts/">HSTS概览</a></details>

</li>
</ul>
</li>
</ol>
<h3 id="HTTPS连接的时候-怎么确定收到的包是服务器发来的-中间人攻击"><a href="#HTTPS连接的时候-怎么确定收到的包是服务器发来的-中间人攻击" class="headerlink" title="HTTPS连接的时候, 怎么确定收到的包是服务器发来的(中间人攻击)?"></a>HTTPS连接的时候, 怎么确定收到的包是服务器发来的(中间人攻击)?</h3><details>
<summary>展开</summary>

<p>![04095322_Ey4I](_v_images/20210224215020750_18194.jpg =550x)</p>
<ul>
<li>中间人截取客户端发送给服务器的请求, 然后<strong>伪装成客户端与服务器进行通信</strong>; 将服务器返回给客户端的内容发送给客户端, <strong>伪装成服务器与客户端进行通信</strong>. 通过这样的手段, 便可以获取客户端和服务器之间通信的所有内容. </li>
<li>具体来讲, 中间人通过截取服务器发送给客户端的公钥, 便能解密客户端发送给服务器的对称加密的密钥, 然后在使用自己生成的对称加密密钥与服务器通信. 并利用客户端的对称加密密钥与客户端进行通信.</li>
<li>使用中间人攻击手段, <strong>必须要让客户端信任中间人的证书</strong>, 如果客户端不信任, 则这种攻击手段也无法发挥作用.</li>
<li>预防: <ul>
<li>针对安全性要求比较高的网站, 可采取<strong>客户端预埋证书</strong>的方式锁死证书, <strong>只有当客户端证书和服务端的证书完全一致的情况下才允许通信</strong>, 如一些银行类的app, 但这种方式面临一个问题, 证书过期的问题, 因证书有一定的有效期, 当预埋证书过期了, 只有通过强制更新或者要求用户下载证书来解决. </li>
<li>针对安全性要求一般的app, 可采用通过<strong>校验域名, 证书有效性、证书关键信息及证书链的方式</strong></li>
</ul>
</li>
</ul>
</details>

<h3 id="什么是对称加密、非对称加密-区别是什么"><a href="#什么是对称加密、非对称加密-区别是什么" class="headerlink" title="什么是对称加密、非对称加密? 区别是什么?"></a>什么是对称加密、非对称加密? 区别是什么?</h3><details>
<summary>展开</summary>

<ul>
<li>对称加密：加密和解密采用相同的密钥. 如：DES、AES</li>
<li>非对称加密：需要两个密钥：公钥和私钥. 如果用公钥加密, 需要用私钥才能解密. (一般基于数学难题) 如：RSA, 椭圆曲线加密</li>
<li>区别：对称加密速度更快, 通常用于大量数据的加密; 非对称加密安全性更高(不需要传送私钥), 一般用于加密对称密钥, 进行数字签名等.</details>

</li>
</ul>
<h3 id="数字签名、报文摘要的原理"><a href="#数字签名、报文摘要的原理" class="headerlink" title="数字签名、报文摘要的原理"></a>数字签名、报文摘要的原理</h3><details>
<summary>展开</summary>

<ul>
<li>数字签名: 发送者A用私钥进行签名, 接收者B用公钥验证签名. 因为除A外没有人有私钥, 所以B相信签名是来自A. A不可抵赖, B也不能伪造报文. 用于保证数据的真实性(防抵赖).</li>
<li>报文摘要: 使用哈希函数: 作用于一任意长度的消息M, 返回一固定长度(通常超过128比特)的散列值. 一般使用迭代结构, 将数据划分为块, 每块使用压缩算法然后迭代. 摘要算法:MD5、SHA. 用于保证数据完整性.<br>![](_v_images/20210224221453476_20608.png =578x)</li>
</ul>
</details>

<h3 id="GET与POST的区别"><a href="#GET与POST的区别" class="headerlink" title="GET与POST的区别?"></a>GET与POST的区别?</h3><details>
<summary>展开</summary>

<ul>
<li>GET一般用于从服务器<strong>获取资源,</strong> 不管调用多少次接口, 结果都不会改变, 本身<strong>不会对资源产生影响, 是幂等的</strong>; 而POST一般用于<strong>修改数据, 有可能改变服务器上的资源, 不是幂等的</strong></li>
<li>请求形式上：GET请求的数据<strong>附在URL之后</strong>, 在HTTP请求头中(以<code>?</code>分割URL和传输数据, 参数之间以<code>&amp;</code>相连); POST请求的数据<strong>在请求体中</strong></li>
<li>GET<strong>只接受ASCII字符(子集, 部分需要转码)的参数的数据类型</strong>; POST对数据类型没有要求, 也允许二进制数据 (GET请求只能进行url编码; 而POST支持多种编码方式)</li>
<li>安全性：GET请求<strong>可被缓存、产生的URL可保存为书签、请求参数保留到历史记录</strong>, 且其请求<strong>数据明文出现在URL中</strong>; POST的<strong>参数不会被保存</strong>, 除非手动设置否则不会被缓存, 安全性相对较高; </li>
<li>GET的<strong>数据大小有限制</strong>(http协议并没有硬性限制, 而是与浏览器、服务器、操作系统有关, 一般最长为2KB);  而POST数据大小无限制(实际取决于服务器的设置和内存大小)</li>
<li>GET在浏览器<strong>回退时是无害</strong>的, 回退后浏览器再缓存中拿结果; <strong>POST会再次提交请求</strong></details>

</li>
</ul>
<h3 id="Session与Cookie"><a href="#Session与Cookie" class="headerlink" title="Session与Cookie"></a>Session与Cookie</h3><h4 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h4><h5 id="Cookie工作原理"><a href="#Cookie工作原理" class="headerlink" title="Cookie工作原理"></a>Cookie工作原理</h5><ol>
<li>浏览器端第一次发送请求到服务器端</li>
<li>服务器端创建Cookie, 该<strong>Cookie中包含用户的信息</strong>, 然后将该Cookie<strong>发送到浏览器端</strong></li>
<li>浏览器端再次访问服务器端时会携带服务器端创建的Cookie</li>
<li>服务器端通过Cookie中携带的数据区分不同的用户<br>![Cookie创建过程](_v_images/20210224232136304_18164.png =547x)<h5 id="Session的工作原理"><a href="#Session的工作原理" class="headerlink" title="Session的工作原理"></a>Session的工作原理</h5></li>
<li>浏览器端第一次发送请求到服务器端, 服务器端创建一个Session, 同时会创建一个特殊的Cookie (name为JSESSIONID的固定值, value为session对象的ID), 然后将该Cookie发送至浏览器端</li>
<li>浏览器端发送第(N&gt;1)次请求到服务器端, 浏览器端访问服务器端时就会携带该name为JSESSIONID的Cookie对象</li>
<li>服务器端根据name为JSESSIONID的Cookie的value(sessionId), 去查询Session对象, 从而区分不同用户<ul>
<li>name为JSESSIONID的Cookie不存在(关闭或更换浏览器), 返回1中重新去创建Session与特殊的Cookie</li>
<li>name为JSESSIONID的Cookie存在, 根据value中的SessionId去寻找session对象</li>
<li>value为SessionId不存在**(Session对象默认存活30分钟)**, 返回1中重新去创建Session与特殊的Cookie</li>
<li>value为SessionId存在, 返回session对象<br>![Session工作原理](_v_images/20210224232446415_16137.png =550x)</li>
</ul>
</li>
</ol>
<h4 id="共同之处："><a href="#共同之处：" class="headerlink" title="共同之处："></a>共同之处：</h4><p>cookie和session都是用来跟踪浏览器用户身份的会话方式.<br>Cookie通过在客户端记录信息确定用户身份, Session通过在服务器端记录信息确定用户身份. </p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul>
<li>存储位置不同<ul>
<li>cookie的数据信息存放在<strong>客户端浏览器</strong>上</li>
<li>session的数据信息存放在<strong>服务器</strong>上. </li>
</ul>
</li>
<li>存储容量不同<ul>
<li>单个cookie保存的<strong>数据&lt;=4KB, 一个站点最多保存20个Cookie</strong></li>
<li>对于session没有限制, 但出于对服务器端的性能考虑, session内不要存放过多的东西, 并且设置session删除机制. </li>
</ul>
</li>
<li>存储方式不同<ul>
<li>cookie中只能保存<strong>ASCII字符串</strong>, 并需要通过编码方式存储Unicode字符或者二进制数据</li>
<li>session中能够存储任何类型的数据, 最好只存储用户信息相关的数据</li>
</ul>
</li>
<li>隐私策略不同<ul>
<li>cookie<strong>对客户端是可见的</strong>, 第三方可以分析存放在本地的cookie, 所以它是不安全的</li>
<li>session存储在服务器上, <strong>对客户端是透明的</strong>, 不存在敏感信息泄漏的风险. </li>
</ul>
</li>
<li>有效期上不同<ul>
<li>开发者可以通过设置cookie的属性, 达到<strong>使cookie长期有效</strong>的效果(maxAge决定着Cookie的有效期, 单位为秒; 存在浏览器进程中的Cookie关闭浏览器失效, 长期有效的Cookie一般被存于磁盘)</li>
<li>session依赖于名为JSESSIONID的cookie, 而cookie JSESSIONID的过期时间默认为-1(由于该cookie的时限), 只需关闭窗口该session就会失效. 此外服务器会把长时间没有活动的Session从服务器内存中清除, Session默认失效时间为30分钟左右. 因而<strong>session不能达到长期有效</strong>的效果</li>
</ul>
</li>
<li>服务器压力不同<ul>
<li>cookie保管在客户端, 不占用服务器资源. 对于并发用户十分多的网站, cookie是很好的选择. </li>
<li>session是保管在服务器端的, 每个用户都会产生一个session. 假如并发访问的用户十分多, 会产生十分多的session, 耗费大量的内存. </li>
</ul>
</li>
<li>浏览器支持不同<ul>
<li>假如客户端浏览器不支持cookie：<ul>
<li>cookie是<strong>需要客户端浏览器支持</strong>的, 假如客户端禁用了cookie, 或者不支持cookie, 则会话跟踪会失效. </li>
<li>运用session需要使用<strong>URL地址重写的方式</strong>, 一切用到session程序的URL都要进行URL地址重写, 否则session会话跟踪还会失效. </li>
</ul>
</li>
<li>假如客户端支持cookie：<ul>
<li>cookie既能够设为本浏览器窗口以及子窗口内有效, 也能够设为一切窗口内有效. </li>
<li>session只能在本窗口以及子窗口内有效(假如两个浏览器窗口互不相干, 它们将运用两个不同的Session)</li>
</ul>
</li>
</ul>
</li>
<li>跨域支持上不同<ul>
<li>cookie<strong>支持跨域名</strong>访问</li>
<li>session不支持跨域名访问. </li>
</ul>
</li>
</ul>
<h3 id="从输入网址到获得页面的过程"><a href="#从输入网址到获得页面的过程" class="headerlink" title="从输入网址到获得页面的过程?"></a>从输入网址到获得页面的过程?</h3><h4 id="1-DNS域名解析"><a href="#1-DNS域名解析" class="headerlink" title="1. DNS域名解析"></a>1. DNS域名解析</h4><p>查询 DNS, 获取域名对应的IP地址</p>
<ol>
<li>查找<strong>浏览器缓存</strong>: 浏览器会缓存DNS记录一段时间</li>
<li>查找<strong>系统缓存</strong>:  从本地hosts文件中查找是否有存储的DNS信息</li>
<li>查找<strong>路由器缓存</strong>: 若之前访问过相应网站, 一般路由器也会缓存信息</li>
<li>查找<strong>ISP(本地DNS服务器)的DNS缓存</strong>——从网络服务商(例如电信)的DNS缓存信息中查找. </li>
<li>向根域名服务器查找: 如果经由以上方式都没找到, 则<strong>向根域名服务器发起递归查询或者迭代查询</strong>域名对应的IP地址. 根域名服务器把请求转发到TLD(顶级域)DNS服务器, 在转发至权威DNS服务器, 逐层查找该域名的对应数据, 直到获得最终解析结果或失败的相应.</li>
</ol>
<ul>
<li>递归查询: 如果主机所询问的本地域名服务器不知道被查询的域名的IP地址, 那么<strong>本地域名服务器就以DNS客户的身份, 向其它根域名服务器继续发出查询请求报文</strong>, 返回的查询结果是所要查询的IP地址或者报错. <strong>主机向本地域名服务器的查询一般都是采用递归查询</strong></li>
<li>迭代查询: 当根域名服务器收到本地域名服务器发出的迭代查询请求报文时, <strong>要么给出所要查询的IP地址, 要么返回能解答该查询的服务器列表</strong>,  然后本地服务器对列表进行后续的查询. 一般本地DNS服务器向根服务器, TLD DNS服务器和权威DNS服务器是迭代查询.<br>![DNS递归查询和迭代查询](_v_images/20210225215456412_20336.png =540x)<h4 id="2-建立TCP连接"><a href="#2-建立TCP连接" class="headerlink" title="2. 建立TCP连接"></a>2. 建立TCP连接</h4>浏览器获得域名对应的IP地址以后, 浏览器<strong>向服务器请求建立链接, 发起TCP三次握手</strong><h4 id="3-发送HTTP请求"><a href="#3-发送HTTP请求" class="headerlink" title="3. 发送HTTP请求"></a>3. 发送HTTP请求</h4>TCP/IP连接建立后, 浏览器向服务器<strong>发送HTTP请求</strong><h4 id="4-服务器处理请求"><a href="#4-服务器处理请求" class="headerlink" title="4. 服务器处理请求"></a>4. 服务器处理请求</h4>服务器接收到这个请求, 并根据<strong>路径参数映射到特定的请求处理器进行处理</strong>, 控制器(Controller)从模型(Model)和视图(View)中获取各种数据信息进行处理, 最后<strong>视图(View)将数据渲染为HTML返回</strong>给浏览器<h4 id="5-浏览器显示页面信息"><a href="#5-浏览器显示页面信息" class="headerlink" title="5.浏览器显示页面信息"></a>5.浏览器显示页面信息</h4></li>
</ul>
<ol>
<li>浏览器<strong>边解析边渲染.</strong> 浏览器解析HTML文件构建DOM树, 根据CSS构建渲染树, 若遇到对<strong>js文件、css文件及图片等静态资源的引用, 则重复上述步骤并向服务器(异步)请求</strong>这些资源. </li>
<li>浏览器等到渲染树构建完成后, 开始布局渲染树并<strong>将其绘制到屏幕</strong>上, 最终向用户呈现一个完整的页面.(加载过程遇到JS文件要等到其由JS解析引擎解析加载执行完毕后再继续渲染).</li>
</ol>
<h3 id="HTTP请求有哪些常见状态码"><a href="#HTTP请求有哪些常见状态码" class="headerlink" title="HTTP请求有哪些常见状态码?"></a>HTTP请求有哪些常见状态码?</h3><p><a target="_blank" rel="noopener" href="https://www.w3cschool.cn/http/g9prxfmx.html">HTTP 响应代码</a></p>
<ul>
<li>2xx状态码：成功响应.  <ul>
<li><strong>200 OK 请求成功</strong></li>
</ul>
</li>
<li>3xx状态码：重定向 <ul>
<li><strong>301 Moved Permanently 永久重定向</strong>. 请求的资源已被永久的移动到新URI, 返回信息会包括新的URI, 浏览器会自动定向到新URI, 今后任何<strong>新的请求都应使用新的URI</strong>代替</li>
<li><strong>302 Found 暂时重定向</strong>. 请求的资源现在临时从不同的 URI 响应请求. 由于这样的重定向是临时的, 客户端应当继续向<strong>原有地址发送以后的请求</strong></li>
<li><strong>304 Not Modified 未修改</strong>. 客户端发送了一个带条件的 GET 请求且该请求已被允许, 而(自上次访问以来或者根据请求的条件)<strong>请求的资源并没有修改, 不返回任何资源</strong>, 即禁止包含消息体. </li>
</ul>
</li>
<li>4xx状态码：客户端错误<ul>
<li><strong>400 Bad Request 请求错误</strong>. 客户端请求的语法错误, 服务器无法理解; 或者请求的参数错误</li>
<li><strong>401 Unauthorized 未授权</strong>. 当前请求<strong>需要用户身份验证</strong></li>
<li><strong>403 Forbidden 禁止</strong>. 服务器已经理解请求, 但是<strong>拒绝执行</strong></li>
<li><strong>404 Not Found 未找到</strong>. 服务器无法根据客户端的请求找到资源</li>
</ul>
</li>
<li>5xx状态码：服务器错误<ul>
<li><strong>500 Internal Server Error 服务器内部错误</strong>. 服务器内部错误, 遇到了不知道如何处理的情况</li>
<li><strong>501 Not Implemented 服务不可用</strong> 服务器不支持请求的功能, 无法完成请求</li>
</ul>
</li>
</ul>
<h3 id="OSI七层模型与TCP-IP五层模型"><a href="#OSI七层模型与TCP-IP五层模型" class="headerlink" title="OSI七层模型与TCP/IP五层模型"></a>OSI七层模型与TCP/IP五层模型</h3><p>![OSI七层模型与TCP/IP五层模型](_v_images/20210225225813101_3369.png =482x)<br>![OSI参考模型](_v_images/20210225225837935_32694.png =491x)</p>
<ul>
<li>应用层: 为应用程序提供服务, 各种<strong>应用程序协议</strong></li>
<li>表示层: 数据<strong>格式转化</strong>, 数据<strong>加密解密</strong>, 数据<strong>压缩解压缩</strong></li>
<li>会话层: 建立,管理和终止<strong>实体间的会话连接</strong></li>
<li>传输层: 数据的<strong>分段及重组</strong>, 提供<strong>进程间的数据传输</strong>服务</li>
<li>网络层: 将<strong>数据从源端传送到目的端</strong>, 逻辑寻址, <strong>路由选择, 分组转发</strong></li>
<li>数据链路层: 实现数据在<strong>网络相邻结点之间的传输</strong>, 差错检测</li>
<li>物理层: 在介质上传输比特流</li>
</ul>
<details>
<summary>路由器、交换机位于哪一层? </summary>

<ul>
<li>路由器位于网络层, 根据IP地址进行寻址; </li>
<li>交换机位于链路层, 根据MAC地址进行寻址</details>

</li>
</ul>
<h2 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h2><h3 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类?"></a>IP地址的分类?</h3><p>![IP address](_v_images/20191201085151639_2895.png =450x)</p>
<p>路由器仅根据网络号net-id来转发分组, 当分组到达目的网络的路由器之后, 再按照主机号host-id将分组交付给主机; 同一网络上的所有主机的网络号相同. </p>
<h3 id="什么叫划分子网"><a href="#什么叫划分子网" class="headerlink" title="什么叫划分子网?"></a>什么叫划分子网?</h3><p><strong>从主机号host-id借用若干个比特作为子网号</strong>subnet-id<br>子网掩码：网络号和子网号都为1, 主机号为0<br>数据报仍然先按照网络号找到目的网络, 发送到路由器, <strong>路由器再按照网络号和子网号找到目的子网</strong>：将子网掩码与目标地址逐比特与操作, 若结果为某个子网的网络地址, 则送到该子网. </p>
<h3 id="什么是ARP协议-Address-Resolution-Protocol"><a href="#什么是ARP协议-Address-Resolution-Protocol" class="headerlink" title="什么是ARP协议 (Address Resolution Protocol)?"></a>什么是ARP协议 (Address Resolution Protocol)?</h3><ul>
<li>ARP协议<strong>完成了IP地址与物理地址的映射</strong>.</li>
<li>每一个主机都设有一个 ARP 高速缓存, 里面有<strong>所在的局域网上的各主机和路由器的 IP 地址到MAC地址的映射表</strong>. </li>
<li>当源主机要发送数据包到目的主机时, 会先检查自己的ARP高速缓存中<strong>有没有目的主机的MAC地址</strong>, 如果有, 就直接将数据包发到这个MAC地址; 如果没有, 就向<strong>所在的局域网</strong>发起一个ARP请求的广播包(在发送自己的 ARP 请求时, 同时会带上自己的 IP 地址到MAC地址的映射), 收到请求的主机检查自己的IP地址和目的主机的IP地址是否一致, 如果一致, 则<strong>先保存源主机的映射到自己的ARP缓存</strong>, 然后给源主机发送一个ARP响应数据包. 源主机收到响应数据包之后, 先添加目的主机的IP地址与MAC地址的映射, 再进行数据传送. 如果源主机一直没有收到响应, 表示ARP查询失败. </li>
<li>如果所要找的主机和源主机<strong>不在同一个局域网</strong>上, 那么就要通过 ARP 找到一个位于本局域网上的某个(网关)路由器的MAC地址, 然后把分组发送给这个路由器, 让这个路由器把分组转发给下一个网络. 剩下的工作就由下一个网络来做. </li>
</ul>
<h3 id="网络层的面向连接和无连接"><a href="#网络层的面向连接和无连接" class="headerlink" title="网络层的面向连接和无连接"></a>网络层的面向连接和无连接</h3><details>
<summary>展开</summary>

<ul>
<li>无连接的网络服务(数据报服务); 面向连接的网络服务(虚电路服务)</li>
<li>虚电路服务：需要<strong>维护连接</strong>(建立,断开), 所有的<strong>数据包经过相同的路径</strong>, 服务质量有较好的保证</li>
<li>数据报服务：每个数据包含目的地址, <strong>数据路由相互独立</strong>(路径可能变化); 网络尽最大努力交付数据, 但<strong>不保证不丢失、不延迟、不错序</strong>; 网络发生拥塞时, 可能会将一些分组丢弃;<br>![virtual circuit](_v_images/20191201081919108_30577.png =450x)</details>


</li>
</ul>
<h3 id="什么是NAT"><a href="#什么是NAT" class="headerlink" title="什么是NAT"></a>什么是NAT</h3><ul>
<li>NAT: Network Address Translation, 网络地址转换. </li>
<li>用于<strong>内网中的主机和因特网上的主机通信</strong>, 解决IP地址不足的问题.</li>
<li>由NAT路由器<strong>将主机的本地IP地址转换为全球IP地址</strong>, 分为静态转换(转换得到的全球IP地址固定不变, 用于隐藏主机真实IP) 和动态NAT转换(内部网络的私有 IP 地址转换为公用 IP 地址时, IP 地址是不确定, 随机的)</li>
</ul>
<h3 id="RIP-算法是什么"><a href="#RIP-算法是什么" class="headerlink" title="RIP 算法是什么"></a>RIP 算法是什么</h3><ul>
<li>RIP: Routing Information Protocol, 距离矢量路由协议. </li>
<li>每个<strong>路由器维护一张表, 记录该路由器到其它网络的”跳数”</strong>, 路由器到与其<strong>直接连接的网络的跳数是1, 每多经过一个路由器跳数就加1</strong>; 更新该表时和相邻路由器交换路由信息; 路由器允许一个路径最多包含15个路由器, 如果跳数为16, 则不可达. <strong>交付数据报时优先选取距离最短的路径</strong>.<br>(PS：RIP是应用层协议, 为网络层服务：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19645407">https://www.zhihu.com/question/19645407</a>)</li>
</ul>
<details>
<summary>优缺点</summary>

<ul>
<li>实现简单, 开销小</li>
<li>随着网络规模扩大开销也会增大; </li>
<li>最大距离为15, 限制了网络的规模; </li>
<li>当网络出现故障时, 要经过较长的时间才能将此信息传递到所有路由器</details>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/02/15/Latex/" rel="next" title="LateX安装与使用">
                <i class="fa fa-chevron-left"></i> LateX安装与使用
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="prev" title="操作系统">
                操作系统 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/VastRock-Huang" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="nav-number">1.</span> <span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%9ATCP%E5%92%8CUDP"><span class="nav-number">1.1.</span> <span class="nav-text">传输层：TCP和UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-three-way-handshake"><span class="nav-number">1.1.1.</span> <span class="nav-text">什么是三次握手 (three-way handshake)?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">第一次握手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">第二次握手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">第三次握手</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E5%8F%AF%E4%BB%A5%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%90%97-%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="nav-number">1.1.2.</span> <span class="nav-text">TCP建立连接可以两次握手吗? 为什么?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E4%BB%A5%E9%87%87%E7%94%A8%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%90%97-%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="nav-number">1.1.3.</span> <span class="nav-text">可以采用四次握手吗? 为什么?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%AD-%E5%A6%82%E6%9E%9C%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84ACK%E6%9C%AA%E9%80%81%E8%BE%BE%E6%9C%8D%E5%8A%A1%E5%99%A8-%E4%BC%9A%E6%80%8E%E6%A0%B7"><span class="nav-number">1.1.4.</span> <span class="nav-text">第三次握手中, 如果客户端的ACK未送达服务器, 会怎样?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5-%E4%BD%86%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%87%BA%E7%8E%B0%E4%BA%86%E6%95%85%E9%9A%9C%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-number">1.1.5.</span> <span class="nav-text">如果已经建立了连接, 但客户端出现了故障怎么办?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%E5%8F%B7%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.1.6.</span> <span class="nav-text">初始序列号是什么?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">1.1.7.</span> <span class="nav-text">什么是四次挥手?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">1.1.7.1.</span> <span class="nav-text">第一次挥手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">1.1.7.2.</span> <span class="nav-text">第二次挥手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">1.1.7.3.</span> <span class="nav-text">第三次挥手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">1.1.7.4.</span> <span class="nav-text">第四次挥手</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%8A%8A%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E7%9A%84ACK%E5%92%8CFIN%E5%90%88%E5%B9%B6%E8%B5%B7%E6%9D%A5-%E5%8F%98%E6%88%90%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B-CLOSE-WAIT%E7%8A%B6%E6%80%81%E6%84%8F%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.1.8.</span> <span class="nav-text">为什么不能把服务器发送的ACK和FIN合并起来, 变成三次挥手(CLOSE_WAIT状态意义是什么)?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%97%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84ACK%E6%B2%A1%E6%9C%89%E9%80%81%E8%BE%BE%E5%AE%A2%E6%88%B7%E7%AB%AF-%E4%BC%9A%E6%80%8E%E6%A0%B7"><span class="nav-number">1.1.9.</span> <span class="nav-text">如果第二次挥手时服务器的ACK没有送达客户端, 会怎样?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AFTIME-WAIT%E7%8A%B6%E6%80%81%E7%9A%84%E6%84%8F%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.1.10.</span> <span class="nav-text">客户端TIME_WAIT状态的意义是什么?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">1.1.11.</span> <span class="nav-text">TCP如何实现流量控制?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%B6%E7%AA%97%E5%8F%A3-%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3%E4%B8%BA0%E6%97%B6%E4%BC%9A%E6%80%8E%E6%A0%B7"><span class="nav-number">1.1.12.</span> <span class="nav-text">什么是零窗口(接收窗口为0时会怎样)?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">1.1.13.</span> <span class="nav-text">TCP的拥塞控制是怎么实现的?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.14.</span> <span class="nav-text">TCP与UDP的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%89%E6%8B%A9TCP-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%89UDP"><span class="nav-number">1.1.15.</span> <span class="nav-text">什么时候选择TCP, 什么时候选UDP?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8UDP%E5%90%97"><span class="nav-number">1.1.16.</span> <span class="nav-text">HTTP可以使用UDP吗?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-number">1.1.17.</span> <span class="nav-text">TCP如何保证传输的可靠性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%9AHTTP%E5%92%8CHTTPS"><span class="nav-number">1.2.</span> <span class="nav-text">应用层：HTTP和HTTPS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E5%92%8CHTTPS%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.1.</span> <span class="nav-text">HTTP和HTTPS有什么区别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS%E7%9A%84%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B"><span class="nav-number">1.2.2.</span> <span class="nav-text">HTTPS的连接过程?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E7%BD%91%E5%9D%80%E7%94%A8HTTP%E8%BF%98%E6%98%AFHTTPS"><span class="nav-number">1.2.3.</span> <span class="nav-text">如何确定网址用HTTP还是HTTPS?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%97%B6%E5%80%99-%E6%80%8E%E4%B9%88%E7%A1%AE%E5%AE%9A%E6%94%B6%E5%88%B0%E7%9A%84%E5%8C%85%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E6%9D%A5%E7%9A%84-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB"><span class="nav-number">1.2.4.</span> <span class="nav-text">HTTPS连接的时候, 怎么确定收到的包是服务器发来的(中间人攻击)?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E3%80%81%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86-%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.2.5.</span> <span class="nav-text">什么是对称加密、非对称加密? 区别是什么?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E3%80%81%E6%8A%A5%E6%96%87%E6%91%98%E8%A6%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">1.2.6.</span> <span class="nav-text">数字签名、报文摘要的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GET%E4%B8%8EPOST%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.7.</span> <span class="nav-text">GET与POST的区别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Session%E4%B8%8ECookie"><span class="nav-number">1.2.8.</span> <span class="nav-text">Session与Cookie</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="nav-number">1.2.8.1.</span> <span class="nav-text">工作原理：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Cookie%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.2.8.1.1.</span> <span class="nav-text">Cookie工作原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Session%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.2.8.1.2.</span> <span class="nav-text">Session的工作原理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B1%E5%90%8C%E4%B9%8B%E5%A4%84%EF%BC%9A"><span class="nav-number">1.2.8.2.</span> <span class="nav-text">共同之处：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.8.3.</span> <span class="nav-text">区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E8%8E%B7%E5%BE%97%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">1.2.9.</span> <span class="nav-text">从输入网址到获得页面的过程?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90"><span class="nav-number">1.2.9.1.</span> <span class="nav-text">1. DNS域名解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.2.9.2.</span> <span class="nav-text">2. 建立TCP连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%8F%91%E9%80%81HTTP%E8%AF%B7%E6%B1%82"><span class="nav-number">1.2.9.3.</span> <span class="nav-text">3. 发送HTTP请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82"><span class="nav-number">1.2.9.4.</span> <span class="nav-text">4. 服务器处理请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E4%BF%A1%E6%81%AF"><span class="nav-number">1.2.9.5.</span> <span class="nav-text">5.浏览器显示页面信息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E8%AF%B7%E6%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">1.2.10.</span> <span class="nav-text">HTTP请求有哪些常见状态码?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E4%B8%8ETCP-IP%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.11.</span> <span class="nav-text">OSI七层模型与TCP&#x2F;IP五层模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.3.</span> <span class="nav-text">网络层协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">1.3.1.</span> <span class="nav-text">IP地址的分类?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E5%8F%AB%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91"><span class="nav-number">1.3.2.</span> <span class="nav-text">什么叫划分子网?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFARP%E5%8D%8F%E8%AE%AE-Address-Resolution-Protocol"><span class="nav-number">1.3.3.</span> <span class="nav-text">什么是ARP协议 (Address Resolution Protocol)?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E5%92%8C%E6%97%A0%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.3.4.</span> <span class="nav-text">网络层的面向连接和无连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFNAT"><span class="nav-number">1.3.5.</span> <span class="nav-text">什么是NAT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RIP-%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.3.6.</span> <span class="nav-text">RIP 算法是什么</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">VastRock-Huang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
