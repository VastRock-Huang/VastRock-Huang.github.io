<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git</title>
    <url>/2021/02/15/Git/</url>
    <content><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="0-基本设置"><a href="#0-基本设置" class="headerlink" title="0. 基本设置"></a>0. 基本设置</h2><ol>
<li>设置用户名邮箱<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;&lt;name&gt;&quot;    # 用户名</span><br><span class="line">git config --global user.email &quot;&lt;email&gt;&quot;    #邮箱</span><br></pre></td></tr></table></figure></li>
<li>查看设置信息<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config -l</span><br></pre></td></tr></table></figure></li>
<li>查看git版本<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git version</span><br></pre></td></tr></table></figure>
<h2 id="1-仓库基本使用"><a href="#1-仓库基本使用" class="headerlink" title="1. 仓库基本使用"></a>1. 仓库基本使用</h2></li>
<li>新建仓库<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li>
<li>查看仓库状态<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></li>
<li>暂存文件: 将工作区的文件存入暂存区<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add &lt;file&gt;     # 可用. 表示全部文件</span><br></pre></td></tr></table></figure></li>
<li>提交文件形成版本<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &lt;description&gt;</span><br></pre></td></tr></table></figure>
<h2 id="2-远程仓库使用"><a href="#2-远程仓库使用" class="headerlink" title="2. 远程仓库使用"></a>2. 远程仓库使用</h2></li>
<li>关联远程仓库<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add &lt;repoName&gt; &lt;repoUrl&gt;</span><br></pre></td></tr></table></figure></li>
<li>查看所关联的远程仓库<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></li>
<li>推送文件到远程仓库<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push &lt;repoName&gt; &lt;branchName&gt;</span><br></pre></td></tr></table></figure></li>
<li>克隆远程仓库<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone &lt;repoUrl&gt;</span><br></pre></td></tr></table></figure></li>
<li>从远程仓库拉取文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull &lt;repoName&gt; &lt;branchName&gt;</span><br></pre></td></tr></table></figure>
<h2 id="3-分支"><a href="#3-分支" class="headerlink" title="3. 分支"></a>3. 分支</h2></li>
<li>查看分支<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></li>
<li>创建分支<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch &lt;branchName&gt;</span><br></pre></td></tr></table></figure></li>
<li>切换分支<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout &lt;branchName&gt;</span><br></pre></td></tr></table></figure></li>
<li>查看当前分支的提交日志<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --oneline    # 建议日志</span><br><span class="line">git log     # 完整日志</span><br></pre></td></tr></table></figure></li>
<li>分支合并: 将某一分支合并到当前分支<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge &lt;branchName&gt;</span><br></pre></td></tr></table></figure>
<h2 id="4-忽略文件-gitignore"><a href="#4-忽略文件-gitignore" class="headerlink" title="4. 忽略文件.gitignore"></a>4. 忽略文件<code>.gitignore</code></h2>将git扫描时忽略的文件填入该文件中</li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>LateX安装与使用</title>
    <url>/2021/02/15/Latex/</url>
    <content><![CDATA[<h1 id="LateX安装与使用"><a href="#LateX安装与使用" class="headerlink" title="LateX安装与使用"></a>LateX安装与使用</h1><h2 id="1-使用"><a href="#1-使用" class="headerlink" title="1. 使用"></a>1. 使用</h2><h3 id="2-1-基本模板"><a href="#2-1-基本模板" class="headerlink" title="2.1 基本模板"></a>2.1 基本模板</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\def</span><span class="keyword">\SetClass</span>&#123;article&#125;</span><br><span class="line"><span class="keyword">\documentclass</span>&#123;<span class="keyword">\SetClass</span>&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>[ruled,linesnumbered]&#123;algorithm2e&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;geometry&#125;</span><br><span class="line"><span class="keyword">\geometry</span>&#123;top=1cm&#125;    <span class="comment">%% 上边距</span></span><br><span class="line"><span class="keyword">\thispagestyle</span>&#123;empty&#125;    <span class="comment">%% 去除页码</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;algorithm&#125;</span><br><span class="line">    <span class="keyword">\renewcommand</span>&#123;<span class="keyword">\thealgocf</span>&#125;&#123;&#125; <span class="comment">%%去除&quot;algorithm&quot;后的序号</span></span><br><span class="line">    <span class="keyword">\SetKwData</span>&#123;Left&#125;&#123;left&#125;<span class="keyword">\SetKwData</span>&#123;This&#125;&#123;this&#125;<span class="keyword">\SetKwData</span>&#123;Up&#125;&#123;up&#125;</span><br><span class="line">    <span class="keyword">\SetKwFunction</span>&#123;Union&#125;&#123;Union&#125;<span class="keyword">\SetKwFunction</span>&#123;FindCompress&#125;&#123;FindCompress&#125;</span><br><span class="line">    <span class="keyword">\SetKwInOut</span>&#123;Input&#125;&#123;Input&#125;<span class="keyword">\SetKwInOut</span>&#123;Output&#125;&#123;Output&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">\Input</span>&#123;Ipt&#125;</span><br><span class="line">    <span class="keyword">\Output</span>&#123;Opt&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">\caption</span>&#123;caption&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;algorithm&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-其他设置"><a href="#2-2-其他设置" class="headerlink" title="2.2 其他设置"></a>2.2 其他设置</h3><ul>
<li>伪代码中的单词:</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>符号</th>
<th>代码</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>for循环中的”to”</td>
<td>$\textbf{to}$</td>
<td><code>\KwTo</code></td>
<td>需要写在公式<code>$$</code>外,注意两边留空格</td>
</tr>
<tr>
<td>条件中的与</td>
<td>$\textbf{and}$</td>
<td><code>\textbf&#123;and&#125;</code></td>
<td>需要写在公式<code>$$</code>外</td>
</tr>
</tbody></table>
<ul>
<li>去除算法”Algorithm”后的序号:<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\thealgocf</span>&#125;&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li>页边距设置:<br>使用宏包”geometry”, 页面的左边距、右边距、上边距、下边距分别对应参数名<code>left</code>, <code>right</code>, <code>top</code>, <code>bottom</code></li>
</ul>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;geometry&#125;</span><br><span class="line"><span class="keyword">\geometry</span>&#123;top=1cm&#125;     <span class="comment">%%上边距为1cm</span></span><br></pre></td></tr></table></figure>
<ul>
<li>去除当前页的页码:</li>
</ul>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\thispagestyle</span>&#123;empty&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-常用语法或符号"><a href="#2-常用语法或符号" class="headerlink" title="2 常用语法或符号"></a>2 常用语法或符号</h2><table>
<thead>
<tr>
<th>名称</th>
<th>符号</th>
<th>代码</th>
</tr>
</thead>
<tbody><tr>
<td>异或</td>
<td>$\oplus$</td>
<td><code>\oplus</code></td>
</tr>
<tr>
<td>圆周率</td>
<td>$\pi$</td>
<td><code>\pi</code></td>
</tr>
<tr>
<td>左箭头</td>
<td>$\leftarrow$</td>
<td><code>\leftarrow</code></td>
</tr>
<tr>
<td>一个字符宽度的空格</td>
<td>$\quad$</td>
<td><code>\quad</code></td>
</tr>
<tr>
<td>小于等于</td>
<td>$\leq$</td>
<td><code>\leq</code></td>
</tr>
<tr>
<td>大于等于</td>
<td>$\geq$</td>
<td><code>\geq</code></td>
</tr>
<tr>
<td>同余/恒等于</td>
<td>$\equiv$</td>
<td><code>\equiv</code></td>
</tr>
<tr>
<td>乘号</td>
<td>$\times$</td>
<td><code>\times</code></td>
</tr>
<tr>
<td>正负号</td>
<td>$\pm$</td>
<td><code>\pm</code></td>
</tr>
<tr>
<td>乘点</td>
<td>$\cdot$</td>
<td><code>\cdot</code></td>
</tr>
<tr>
<td>上横线</td>
<td>$\overline{x}$</td>
<td><code>\overline&#123;x&#125;</code></td>
</tr>
<tr>
<td>无穷</td>
<td>$\infty$</td>
<td><code>\infty</code></td>
</tr>
<tr>
<td>求和</td>
<td>$\sum_{i=0}^{n}$</td>
<td><code>\sum_&#123;i=0&#125;^&#123;n&#125;</code></td>
</tr>
<tr>
<td>分数</td>
<td>$\frac{x}{y}$</td>
<td><code>\frac&#123;x&#125;&#123;y&#125;</code></td>
</tr>
<tr>
<td>阿尔法</td>
<td>$\alpha$</td>
<td><code>\alpha</code></td>
</tr>
<tr>
<td>波浪号</td>
<td>$\sim$</td>
<td><code>\sim</code></td>
</tr>
</tbody></table>
<ul>
<li>需要转义的字符:<ul>
<li>$&amp;$: <code>\&amp;</code></li>
<li>$%$: <code>\%</code></li>
<li>$#$: <code>\#</code></li>
<li>$_$: <code>\_</code></li>
<li>${$和$}$: <code>\&#123;</code>和<code>\&#125;</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>LateX</category>
      </categories>
      <tags>
        <tag>LateX</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2021/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><hr>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程和线程有什么区别？"><a href="#进程和线程有什么区别？" class="headerlink" title="进程和线程有什么区别？"></a>进程和线程有什么区别？</h3><details>
<summary>展开</summary>

<ul>
<li>进程（Process）是<strong>系统资源分配的基本单位</strong>; 线程（Thread）是<strong>CPU调度和执行的基本单位</strong></li>
<li>进程是运行中的程序; 线程是进程内部的一个执行序列</li>
<li>包含关系: <strong>一个进程至少有一个线程</strong>; 线程依赖于进程而存在, <strong>线程是进程的一部分</strong></li>
<li>内存分配: 进程间的<strong>地址空间(代码段, 数据段)相互独立</strong>; 线程<strong>共享所属进程的地址空间</strong></li>
<li>进程是拥有<strong>系统资源的一个独立单位</strong>, 每个进程都有独立的地址空间, 打开的文件、信号量、所属用户id、进程控制块; 而线程本身基本上不拥有系统资源，只拥有一点<strong>在运行中必不可少的资源(如程序计数器PC,一组寄存器,栈,TLS,状态)**，和其他线程</strong>共享本进程的相关资源**如堆、I/O、等；</li>
<li>进程切换时，涉及到整个当前进程CPU环境的保存和环境的设置, 以及新被调度运行的进程的CPU环境的设置, <strong>切换有较大开销</strong>; 而线程切换只需保存和设置少量的寄存器的内容，不涉及存储器管理方面的操作, <strong>线程切换的开销较小, 速度更快</strong>.</li>
<li>进程之间的通信需要以<strong>IPC(进程间通信)的方式进行, 如管道, 共享内存, 消息队列, 套接字等, 通讯困难</strong>；线程间可以<strong>直接读写进程数据段（如全局变量）来进行通信</strong>, 但需要线程同步和互斥手段的辅助以保证数据的一致性, <strong>通讯更方便</strong></li>
<li>多进程程序中<strong>一个进程崩溃(保护模式下)并不会对其它进程造成影响</strong>(因为进程地址空间独立); 多线程程序<strong>只要有一个线程崩溃，整个程序就会崩溃</strong>. 因此多进程比多线程更加健壮</li>
<li>进程有程序运行的入口、顺序执行序列和程序出口, <strong>进程可以独立执行; 线程不能独立执行</strong>, 必须依附于进程存在</details>

</li>
</ul>
<h4 id="同一进程中的线程可以共享哪些数据？"><a href="#同一进程中的线程可以共享哪些数据？" class="headerlink" title="同一进程中的线程可以共享哪些数据？"></a>同一进程中的线程可以共享哪些数据？</h4><details>
<summary>展开</summary>

<ul>
<li>进程<strong>代码段</strong></li>
<li>进程的<strong>公有数据（全局变量、静态变量…）</strong></li>
<li>进程<strong>打开的文件描述符</strong></li>
<li>进程的<strong>当前(工作)目录</strong></li>
<li><strong>信号处理器/信号处理函数</strong>：对收到的信号的处理方式</li>
<li><strong>进程ID与进程组ID</strong></details>

</li>
</ul>
<h4 id="线程独占哪些资源？"><a href="#线程独占哪些资源？" class="headerlink" title="线程独占哪些资源？"></a>线程独占哪些资源？</h4><details>
<summary>展开</summary>

<ul>
<li><strong>线程ID</strong></li>
<li><strong>TLS</strong>: Thread Local Storage, 线程局部存储</li>
<li><strong>一组寄存器的值</strong>(包括<strong>程序计数器PC</strong>)</li>
<li>线程自身的<strong>栈</strong>（堆是共享的）</li>
<li><strong>错误返回码</strong>：线程可能会产生不同的错误返回码，一个线程的错误返回码不应该被其它线程修改；</li>
<li><strong>信号掩码/信号屏蔽字</strong>(Signal mask)：表示是否屏蔽/阻塞相应的信号（SIGKILL,SIGSTOP除外）</li>
<li><strong>线程优先级</strong></details>

</li>
</ul>
<h3 id="进程间通信有哪些方式？"><a href="#进程间通信有哪些方式？" class="headerlink" title="进程间通信有哪些方式？"></a>进程间通信有哪些方式？</h3><ol>
<li>匿名管道(Pipe)<details>
<summary>展开</summary>
</li>
</ol>
<ul>
<li>管道是<strong>单工的, 数据只能向一个方向流动</strong>. 需要双方通信时，需要建立起两个管道；进程间通信方式</li>
<li>管道的实质是一个内核缓冲区, 进程以<strong>先进先出</strong>(FIFO)方式从缓冲区存取数据, <strong>一个进程向管道中写的数据被管道另一端的进程读出</strong>. 当缓冲区写满或者读空的时候，相应的进程会进入等待队列.</li>
<li>面向字节流</li>
<li>只能用于父子进程或者兄弟进程之间(具<strong>有亲缘关系的进程</strong>)</li>
<li>Linux中, 使用 <code>pipe()</code>函数创建匿名管道, <strong>无需显示打开, 退出后自动释放</strong>. 其中<code>fd[0]</code>用于读数据, <code>fd[1]</code>用于写数据; 每个进程需要使用<code>close()</code>函数关闭一端, 另一端使用文件I/O<code>read()</code>或<code>write()</code>函数进行读写.</details>
</li>
</ul>
<ol start="2">
<li>命名管道(FIFO)<details>
<summary>展开</summary>
</li>
</ol>
<ul>
<li>提供一个<strong>路径名与之关联</strong>，以FIFO的<strong>文件形式存储文件系统</strong>中(可控制所有权和权限), 但 FIFO 中的<strong>内容却存放在内存</strong>, 通信的两进程结束后会丢失, 但文件路径仍存在</li>
<li><strong>允许无亲缘关系进程间的通信</strong>, 且允许多个进程通过其通信</li>
<li><strong>半双工</strong>的通信方式, 单向传输数据, 但两端都可用来读写</li>
<li>Linux中, 使用<code>mkfifo()</code>或<code>mknod()</code>函数创建命名管道, <strong>需要使用<code>open()</code>函数显示打开</strong>和<code>close()</code>关闭, 采用文件I/O<code>read()</code>和<code>write()</code>读写</details>
</li>
</ul>
<ol start="3">
<li>消息队列<details>
<summary>展开</summary>
</li>
</ol>
<ul>
<li>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。</li>
<li><strong>存放在内核</strong>(的内存)中，只有在<strong>内核重启</strong>(即操作系统重启)或者<strong>显示地删除</strong>时，该消息队列才会被真正的删除</li>
<li>允许一个或多个进程向它写入或者读取消息，并且<strong>每条消息都有类型</strong></li>
<li>消息队列可以实现<strong>消息的随机查询</strong>, 消息可以<strong>按先进先出的次序</strong>读取, 也可以<strong>按消息的类型</strong>读取(第一个).</li>
<li>与无名管道、有名管道一样，从消息队列中读出消息，消息队列中数据会被删除。</li>
<li>在Linux中, 使用<code>msgget()</code>函数创建消息队列, 使用<code>msgsnd()</code>函数向队列添加消息, 使用<code>msgrcv()</code>(可以按类型)</details>
</li>
</ul>
<ol start="4">
<li>信号(Signal)<details>
<summary>展开</summary>
</li>
</ol>
<ul>
<li>信号可<strong>由进程, 操作系统内核和硬件发送</strong>. 可在<strong>任何时候</strong>发给某一进程，而无需知道该进程的状态, 是进程间<strong>唯一的一种异步通信方式</strong></li>
<li><ul>
<li>信号产生时会<strong>设置此信号传递的对象</strong>（一般为对应进程的pid）, 然后传递给操作系统；</li>
<li>操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果该进程处于阻塞状态并未执行，则该信号就有内核保存起来，直到该进程恢复执行并传递给它为止; 如果对应进程已经退出，则丢弃此信号;  如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞,  如果对应进程没有阻塞，操作系统将传递此信号。</li>
<li>目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时<strong>终止当前代码的执行，保护上下文</strong>（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而**执行中断服务程序(即相应的信号处理函数)**，执行完成后在回复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。</li>
</ul>
</li>
<li>Linux中定义了62种信号, 常用的有<code>SIGINT</code> <code>SIGQUIT</code> <code>SIGALRM</code> 等, <strong>使用<code>kill(pid, sig)</code>函数发送信号, 使用<code>signal(sig, func)</code>函数注册信号处理函数</strong>.</details>


</li>
</ul>
<ol start="5">
<li>共享内存<details>
<summary>展开</summary>
</li>
</ol>
<ul>
<li>内核专门留出了一块内存区，可以由需要访问的<strong>进程将其映射到自己的私有地址空间</strong>(进程的逻辑地址有页表转换为物理地址后相同).</li>
<li>使得多个进程可以可以直接读写<strong>同一块物理内存空间</strong>，不需要系统调用，不涉及用户态到内核态的转换，也不需要对数据不必要的复制. 是<strong>最快</strong>的可用IPC形式.</li>
<li><strong>存在并发问题, 需要依靠某种同步机制</strong>（如信号量）来达到进程间的同步及互斥。</li>
<li><strong>生命周期也是随内核</strong>, 使用命令删除一个共享内存的时候，需要等到所有进程都<strong>与共享内存解除映射之后才删除</strong></li>
<li>Linux中, 使用<code>shmget()</code>函数创建共享内存; <code>shmat()</code>函数把共享内存映射到调用进程空间(挂接到进程的页表), 返回共享内存虚拟地址; 使用<code>shmdt()</code>函数断开进程与共享内存的绑定.</details>
</li>
</ul>
<ol start="6">
<li>信号量(Semaphore)</li>
</ol>
<details>
<summary>展开</summary>

<ul>
<li>信号量可以<strong>用于实现进程或线程的互斥和同步</strong>, 并<strong>不用来进行数据传输</strong>.</li>
<li>是一种特殊的变量，对它的操作都是原子的. </li>
<li>有两种操作：<strong>P操作：信号量-1</strong>，若<strong>小于0，则进程进入阻塞状态</strong>；<strong>V操作：信号量+1</strong>，若<strong>小于等于0，则从队列中唤醒一个等待的进程进入就绪态</strong></li>
<li>Linux中, 使用<code>semget()</code>函数创建或获得信号量; 使用<code>semop()</code>进行P或V操作(信号量+1-1); 使用<code>semctl()</code>设置信号量如SETVAL用于设置信号量初值, IPC_RMID删除信号量</details>
</li>
</ul>
<ol start="7">
<li>套接字(Socket)</li>
</ol>
<ul>
<li>Ref: <ul>
<li><a href="https://www.jianshu.com/p/c1015f5ffa74">进程间通信IPC (InterProcess Communication) - 简书</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/109550924">浅析进程间通信的几种方式（含实例源码） - 知乎</a></li>
<li><a href="https://blog.csdn.net/ludan_xia/article/details/105653707">进程间七种通信方法，IPC的各种应用场景和优缺点 - CSDN</a></li>
<li><a href="https://imageslr.github.io/2020/02/26/ipc.html#%E7%AE%A1%E9%81%93-pipe">【操作系统】进程间的通信方式 - GitHub</a></li>
</ul>
</li>
</ul>
<h3 id="进程有哪几种状态？"><a href="#进程有哪几种状态？" class="headerlink" title="进程有哪几种状态？"></a>进程有哪几种状态？</h3><p><img src="_v_images/20191202090217863_1873.png" alt="Process State"></p>
<ul>
<li>运行状态：进程<strong>占用CPU, 在CPU上运行</strong>, 处于此状态的进程数小于等于CPU数</li>
<li>就绪状态：进程已获得除CPU外的所需资源<strong>具备运行条件, 等待分配CPU资源</strong></li>
<li>阻塞状态：进程<strong>等待某项服务完成或信号到来</strong>等条件, 在条件满足之前无法执行</li>
</ul>
<h3 id="进程调度策略有哪些"><a href="#进程调度策略有哪些" class="headerlink" title="进程调度策略有哪些"></a>进程调度策略有哪些</h3><h4 id="1-批处理系统"><a href="#1-批处理系统" class="headerlink" title="1 批处理系统"></a>1 批处理系统</h4><p>批处理系统目标是: 最大化每小时作业数, 最小化从提交到完成的时间间隔（衡量了用户等待一个输出的平均时间), 保持CPU始终忙碌</p>
<ol>
<li><strong>先来先服务</strong>调度算法 first-come first-serverd (FCFS)<details>
<summary> 展开 </summary>
</li>
</ol>
<ul>
<li>既可用于进程调度，也可用于作业调度。<ul>
<li>在进程调度中采用FCFS算法时，则每次调度是<strong>从就绪队列中选择一个最先进入该队列的进程</strong>，为之分配处理机</li>
<li>在作业调度中时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列</li>
<li><strong>非抢占式</strong>，开销小，<strong>无饥饿问题</strong>，响应时间不确定(可能很慢)</li>
<li>只考虑作业的等候时间, 没考虑运行时间长短. <strong>对短进程不利, 对I/O密集型进程不利</strong></details>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>短作业优先</strong>调度算法 shortest job first（SJF）<details>
<summary>展开</summary>
</li>
</ol>
<ul>
<li>按估计<strong>运行时间最短的顺序</strong>进行调度</li>
<li>可以分别用于作业调度和进程调度。<ul>
<li>从就绪队列中<strong>选出一个估计运行时间最短的进程</strong>，将处理机分配给它，使它<strong>立即执行并一直执行到完成</strong>，或 发生某事件而被阻塞放弃处理机时再重新调度。</li>
<li>短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内 存运行。</li>
</ul>
</li>
<li><strong>非抢占式</strong>，吞吐量高，开销可能较大，<strong>可能导致饥饿</strong>问题；</li>
<li>对短进程提供好的响应时间，对长进程不利。</details>
</li>
</ul>
<ol start="3">
<li><strong>最短剩余时间优先</strong> shortest remaining time next（SRTN）<details>
<summary>展开</summary>
</li>
</ol>
<ul>
<li>按<strong>剩余运行时间的顺序</strong>进行调度。</li>
<li><strong>最短作业优先的抢占式版本</strong>。若新就绪的进程运行时间比正在执行的进程剩余运行时间短，则新进程将抢占CPU</li>
<li>吞吐量高，开销可能较大，提供好的响应时间, <strong>可能导致饥饿问题</strong>，对长进程不利。</details>
</li>
</ul>
<ol start="4">
<li><strong>最高响应比优先</strong> Highest Response Ratio Next（HRRN）<details>
<summary>展开</summary>
</li>
</ol>
<ul>
<li><strong>响应比 = 响应时间 / 运行时间 = (等待时间 + 运行时间) / 运行时间 = 1+ 等待时间/运行时间</strong>. </li>
<li>选择<strong>响应比最高的作业优先投入运行</strong>.</li>
<li>同时考虑了等待时间的长短和估计需要的执行时间长短，很好的平衡了长短进程。</li>
<li><strong>非抢占</strong>，吞吐量高，开销可能较大(每次调度前都要计算响应比)，提供好的响应时间，<strong>无饥饿问题</strong>。</details>

</li>
</ul>
<h4 id="2-交互式系统"><a href="#2-交互式系统" class="headerlink" title="2. 交互式系统"></a>2. 交互式系统</h4><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p>
<ol>
<li><strong>时间片轮转</strong> Round Robin<details>
<summary>展开</summary>
</li>
</ol>
<ul>
<li>将所有<strong>就绪进程按 先进先出(FCFS) 的原则排成一个队列</strong>. 进程<strong>以时间片为单位轮流使用CPU</strong>, 刚用完时间片的进程排到队列最后。</li>
<li>每个就绪进程都有机会获得CPU(公平性), 且等待有限时间就可重新获得CPU(交互性)</li>
<li><strong>抢占式（时间片用完时）</strong>，开销小，<strong>无饥饿问题</strong>，为短进程提供好的响应时间</li>
<li>若时间片小，进程切换频繁，吞吐量低；若时间片太长，实时性得不到保证。</details>
</li>
</ul>
<ol start="2">
<li><strong>优先级</strong>调度算法<details>
<summary>展开</summary>
</li>
</ol>
<ul>
<li>为每个进程分配一个优先级，按优先级进行调度(选择<strong>优先级最高的进程分配CPU</strong>)</li>
<li>进程的<strong>优先级分为静态优先级和动态优先级</strong>.<ul>
<li>静态优先级创建时确定, 运行时不变. 基于进程所需资源,运行时间,进程类型确定</li>
<li>动态优先级在进程运行时可以改变: 当进程使用CPU超过一定时长(降低),进行I/O操作(升高),等待超过一定时长(升高)都会改变.</li>
</ul>
</li>
<li><strong>分为抢占式和非抢占式</strong>. 前者当系统中出现优先权更高的进程，则立即停止当前执行，并将处理机分配给新到的优先权最高的进程; 后者则在原进程执行完后在分配给新进程.</details>
</li>
</ul>
<ol start="3">
<li>多级反馈队列调度算法 Multilevel Feedback Queue<details>
<summary>展开</summary>
</li>
</ol>
<ul>
<li>设置<strong>多个就绪队列</strong> 1、2、3…，<strong>优先级递减，时间片递增</strong>。进程在进入待调度的队列等待时，首先进入优先级最高的Q1等待</li>
<li>只有等到<strong>优先级更高的队列为空时才会调度当前队列中的进程</strong>。如果<strong>进程用完了当前队列的时间片还未执行完，则会被移到下一队列</strong>。若此时已经是在最下级的队列，则重新放回该队列队尾。</li>
<li>抢占式: 时间片用完时会被下一进程抢占; 有<strong>高优先级的进程到达, 则放弃正在调度的进程(放回当前队列的队尾)，转向调度最高优先级的进程</strong></li>
<li>同一个队列中的各个进程，按照时间片轮转法调度</li>
<li>开销可能较大，对IO型进程有利，可能会出现饥饿问题。</details>

</li>
</ul>
<h4 id="什么叫优先级反转？如何解决？"><a href="#什么叫优先级反转？如何解决？" class="headerlink" title="什么叫优先级反转？如何解决？"></a>什么叫优先级反转？如何解决？</h4><details>
<summary>展开</summary>

<ul>
<li><p><strong>高优先级的进程等待被一个低优先级进程占用的资源</strong>时，就会出现优先级反转，即<strong>优先级较低的进程比优先级较高的进程先执行</strong>。</p>
</li>
<li><p>解决方法：</p>
<ul>
<li>优先级天花板(priority ceiling)：当任务申请某资源时，<strong>把该任务的优先级提升到</strong>可访问这个资源的*<em>所有任务中的最高优先级**</em>，这个优先级称为该资源的优先级天花板。简单易行。</li>
<li>优先级继承(priority inheritance)：当任务A申请共享资源S时，如果S正在被任务C使用，通过比较任务C与A自身的优先级，如发现任务C的优先级小于A自身的优先级，则<strong>将任务C的优先级提升到A自身的优先级</strong>，任务C释放资源S后，再恢复任务C的原优先级。</details>

</li>
</ul>
</li>
</ul>
<h3 id="什么是僵尸进程？"><a href="#什么是僵尸进程？" class="headerlink" title="什么是僵尸进程？"></a>什么是僵尸进程？</h3><details>
<summary>展开</summary>

<ul>
<li>一个进程使用fork创建子进程, 当<strong>子进程比父进程先结束</strong>，而<strong>父进程又 没有调用 <code>wait</code> 或者 <code>waitpid</code> 回收子进程</strong>，释放子进程占用的资源, 那么这个子进程将成为一个僵尸进程。</li>
<li>系统调用 <code>exit</code> 的作用是使进程退出，仅限于将一个正常的进程变成一个僵尸进程，并不能将其完全销毁。</li>
<li>一个进程在调用exit命令结束自己生命的时候，并没有真正的被销毁，而是留下一个称为僵尸进程（Zombie）的数据结构。它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，<strong>仅在进程表中保留一个位置，记载该进程的进程ID、退出状态以及资源利用信息(CPU时间，内存使用量等等)等供父进程收集</strong>，除此之外，僵尸进程不再占有任何内存空间。</li>
<li>若父进程结束，则init进程自动会接手这个子进程，对其回收. 但是如果<strong>父进程</strong>是一个循环，<strong>不会结束</strong>，那么<strong>子进程将一直保持僵尸状态, 一直留在系统中直到系统重启</strong>。</li>
<li>危害：<strong>占用进程号</strong>，而系统所能使用的进程号是有限的；<strong>占用内存</strong>。</li>
<li>避免(不会产生僵尸进程)：<ol>
<li><strong>结束父进程, 让僵尸进程变为孤儿进程, 由init进程接管并回收</strong>。每个进程结束的时候，系统都会扫描是否存在子进程，如果有则用Init进程接管，成为该进程的父进程，并且会调用wait等待其结束。</li>
<li><strong>父进程调用 wait 或者 waitpid 等待子进程结束</strong>（需要<strong>每隔一段时间查询</strong>子进程是否结束）。<ul>
<li>wait系统调用会使父进程暂停执行，直到它的一个子进程结束为止。</li>
<li>waitpid则可以加入<code>WNOHANG</code>(wait-no-hang) 选项，如果没有发现结束的子进程，就会立即返回，不会将调用 waitpid 的进程阻塞。同时，waitpid还可以选择是等待任一子进程（同wait），还是等待指定pid的子进程，还是等待同一进程组下的任一子进程，还是等待组ID等于pid的任一子进程；</li>
</ul>
</li>
<li><strong>捕捉 SIGCHLD 信号，并在信号处理函数中调用wait或waitpid函数</strong>. <strong>子进程结束时，系统会产生 SIGCHLD(signal-child) 信号</strong>，可以注册一个信号处理函数，在该函数中调用waitpid，等待所有结束的子进程（注意：一般都需要循环调用waitpid，因为在信号处理函数开始执行之前，可能已经有多个子进程结束了，而信号处理函数只执行一次，所以要循环调用将所有结束的子进程回收）；</li>
<li>父进程不关心子进程什么时候结束, 可以<strong>用<code>signal(SIGCLD, SIG_IGN)</code>(signal-ignore)通知内核，表示忽略<code>SIGCHLD</code>信号</strong>，那么子进程结束后，<strong>内核会进行回收</strong>。</details>

</li>
</ol>
</li>
</ul>
<h3 id="什么是孤儿进程？"><a href="#什么是孤儿进程？" class="headerlink" title="什么是孤儿进程？"></a>什么是孤儿进程？</h3><details>
<summary>展开</summary>

<p>一个<strong>父进程已经结束了，但是它的子进程还在运行</strong>，那么这些子进程将成为孤儿进程。<br><strong>孤儿进程会被init</strong>（进程ID为1, 用户机开启时开始工作，在用户机结束时终止）<strong>接管</strong>，当这些孤儿进程结束时由Init<strong>完成状态收集工作</strong>。</p>
</details>

<h3 id="并发、并行、异步"><a href="#并发、并行、异步" class="headerlink" title="并发、并行、异步"></a>并发、并行、异步</h3><details>
<summary>展开</summary>

<ul>
<li>并发：在<strong>一个时间段</strong>中同时有多个程序在运行，但微观上<strong>任一时刻只有一个程序在CPU上运行</strong>，宏观上的并发是通过不断的切换实现的；</li>
<li>并行（和串行相对）：在多CPU系统中，多个程序无论<strong>宏观还是微观上都是同时执行的</strong></li>
<li>异步（和同步相对）：异步是<strong>过程调用发出后</strong>，调用者<strong>在没有得到结果之前，就可以继续执行后续操作</strong>。当这个调用完成后，一般<strong>通过状态、通知和回调来通知</strong>调用者。(同步是发出一个功能调用时，<strong>在没有得到结果之前，该调用就不返回或不继续执行后续操作</strong>)</li>
<li>多线程：并发或并行运行的一段代码, 是实现异步的手段</details>


</li>
</ul>
<h3 id="进程同步问题"><a href="#进程同步问题" class="headerlink" title="进程同步问题"></a>进程同步问题</h3><p>进程的同步是目的，而进程间通信是实现进程同步的手段</p>
<h4 id="临界资源和临界区"><a href="#临界资源和临界区" class="headerlink" title="临界资源和临界区"></a>临界资源和临界区</h4><details>
<summary>展开</summary>

<ul>
<li>临界资源: <strong>一次只允许一个进程独占访问使用</strong>的资源</li>
<li>临界区: 各个进程中<strong>对临界资源进行操作的程序片段</strong></details>

</li>
</ul>
<h4 id="进程的同步与互斥"><a href="#进程的同步与互斥" class="headerlink" title="进程的同步与互斥"></a>进程的同步与互斥</h4><details>
<summary>展开</summary>

<ul>
<li>同步：<strong>多个进程因为合作</strong>而使得进程的执行有一定的先后顺序。<strong>一个进程执行到某一步时，必须等待另一个进程</strong>发来信息才能继续运行下去. </li>
<li>互斥：多个进程在<strong>同一时刻只有一个进程能进入临界区</strong>访问临界资源</details>

</li>
</ul>
<h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h4><ul>
<li>问题描述：使用一个缓冲区来存放数据. 只有缓冲区没有满，生产者才可以写入数据；只有缓冲区不为空，消费者才可以读出数据. <strong>每个时刻只有1个</strong>生产者或消费者能存或取缓冲区. </li>
<li>伪代码实现：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义信号量</span></span><br><span class="line">semaphore full = <span class="number">0</span>;    <span class="comment">//缓冲区数据个数</span></span><br><span class="line">semaphore empty = n;    <span class="comment">//缓冲区空位个数 n为缓冲区大小</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;    <span class="comment">//缓冲区读写的互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者进程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">   	  P(empty);    <span class="comment">//有空位才写</span></span><br><span class="line">	  P(mutex);    <span class="comment">//互斥操作</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//生产者进行生产 - 存一个数据到缓冲区</span></span><br><span class="line">   	</span><br><span class="line">   	  V(mutex);</span><br><span class="line">   	  V(full);    <span class="comment">//有了数据,可唤醒阻塞的消费者进程</span></span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者进程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">	  P(full);    <span class="comment">//有数据才读</span></span><br><span class="line">	  P(mutex);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//消费者进行消费 - 从缓冲区读1个数据</span></span><br><span class="line"></span><br><span class="line">	  V(mutex);</span><br><span class="line">	  V(empty);    <span class="comment">//有了空位,可唤醒阻塞的生产者进程</span></span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h4><ul>
<li>问题描述: 有一本书. 有多个读者读书, 有多个读者编书. 要求: 允许多个读者同时读书(可多个用户读操作), 不允许读者编者同时操作(读写互斥), 不允许多个编者同时操作(写操作互斥).</li>
<li>伪代码实现:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//信号量</span></span><br><span class="line">semaphore readCount = <span class="number">0</span>;    <span class="comment">//读者计数</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;        <span class="comment">//readCount的互斥量</span></span><br><span class="line">semaphore editor = <span class="number">1</span>;        <span class="comment">//编者读者的互斥量</span></span><br><span class="line"><span class="comment">//semaphore editorFirst = 1;    //实现编者优先的互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读者进程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//P(editorFirst);    //没有编者时可以增加读者人数</span></span><br><span class="line">                             <span class="comment">//否则会阻塞, 不允许继续添加读者</span></span><br><span class="line">        P(mutex);            <span class="comment">//readCount互斥操作</span></span><br><span class="line">        ++readCount;</span><br><span class="line">        <span class="keyword">if</span>(readCount == <span class="number">1</span>)    <span class="comment">//有读者时</span></span><br><span class="line">            P(editor);        <span class="comment">//读者与编者互斥</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        <span class="comment">//V(editorFirst);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//读者读书</span></span><br><span class="line"></span><br><span class="line">        P(mutex);</span><br><span class="line">        --readCount;</span><br><span class="line">        <span class="keyword">if</span>(readCount == <span class="number">0</span>)    <span class="comment">//没有读者时</span></span><br><span class="line">            V(editor);        <span class="comment">//允许编者写书</span></span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编者进程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Editor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//P(editorFirst);    //有编者时</span></span><br><span class="line">        P(editor);    <span class="comment">//读者编者互斥</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//编者编书</span></span><br><span class="line">    </span><br><span class="line">        V(editor);</span><br><span class="line">        <span class="comment">//V(editorFirst);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>以上解法为读者优先. 有读者则编者一直无法编写, 可能会造成读者饥饿.</li>
<li>带信号量<code>editorFirst</code>后为写者优先. 当有写者要进行写操作时, 便不允许后续增加读者, 而是等写者编写完后才能增加.</li>
</ol>
<h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><ul>
<li><p>问题描述：有 n (5) 位哲学家围绕着餐桌坐，每一位哲学家要么思考，要么吃饭。为了吃饭，哲学家必须拿起两双筷子（分别放于左右两端）不幸的是，筷子的数量和哲学家相等，所以每只筷子必须由两位哲学家共享。要求: 拿一双筷子才能吃饭, 每次只能取一支, 只能拿身边的筷子, 吃完饭才放下筷子</p>
</li>
<li><p>该问题会导致死锁, 避免死锁有多种策略.</p>
<ul>
<li><p>策略1: <strong>限制就餐人数. 至多允许 n-1 个哲学家同时进餐</strong>. 这样能够保证至少一位哲学家能够就餐, 从而进餐后能够释放资源供其他哲学家使用.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore chopsticks[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;<span class="comment">//筷子的互斥信号量</span></span><br><span class="line">semaphore room = <span class="number">4</span>;     <span class="comment">//能够进餐的人数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">		think();</span><br><span class="line">		P(room);    <span class="comment">//准备拿筷子进餐, 进餐会占用1个位置</span></span><br><span class="line">		            <span class="comment">//当没有位置时阻塞, 禁止拿筷子进餐</span></span><br><span class="line">		P(chopstick[i]);</span><br><span class="line">		P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">		eat();    <span class="comment">//进餐</span></span><br><span class="line">		V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">		V(chopstick[i]);</span><br><span class="line">		V(room);    <span class="comment">//进餐完毕, 可进餐人数+1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>策略2:预先分配资源. <strong>仅当哲学家左右筷子都能拿起时才会让其进餐</strong>. 具体实现为使用互斥量确保每次仅有一个人能够拿筷子, <strong>拿完一双后, 下一个人才能拿筷子(相当于将拿一双筷子变为原子操作)</strong>. 这样就不会出现每个人只拿一只筷子的情况.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;  <span class="comment">//取筷子互斥信号量, 每次仅一人能拿筷子</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">     	think();</span><br><span class="line">     	P(mutex);    <span class="comment">//拿筷子信号量, 有它人取筷子时会阻塞</span></span><br><span class="line">     	P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">     	P(chopstick[i]);</span><br><span class="line">     	V(mutex);    <span class="comment">//拿完筷子,其他人可以拿筷子</span></span><br><span class="line">     	eat();</span><br><span class="line">     	V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">// 释放右手边的筷子</span></span><br><span class="line">     	V(chopstick[i]); <span class="comment">// 释放左手边的筷子</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure></li>
<li><p>策略3: 规定奇数号的哲学家先拿起他左边的筷子，然后再去拿他右边的筷子；而偶数号的哲学家则先拿起他右边的筷子，然后再去拿他左边的筷子。按此规定，将是1、2号哲学家竞争1号筷子，3、4号哲学家竞争3号筷子。即五个哲学家都竞争奇数号筷子，获得后，再去竞争偶数号筷子，最后总会有一个哲学家能获得两支筷子而进餐。</p>
</li>
</ul>
</li>
</ul>
<h4 id="管程-Monitor"><a href="#管程-Monitor" class="headerlink" title="管程 Monitor"></a>管程 Monitor</h4><ul>
<li>管程<strong>将共享变量以及对这些共享变量的操作封装起来，形成一个具有一定接口的功能模块</strong>，这样只能通过管程提供的某个过程才能访问管程中的资源。<strong>进程只能互斥地使用管程，使用完之后必须释放管程</strong>并唤醒入口等待队列中的进程。</li>
<li>HOARE管程: <ul>
<li>当一个进程试图进入管程时，在<strong>入口等待队列</strong>等待。若P进程唤醒了Q进程，则Q进程先执行，P在<strong>紧急等待队列</strong>中等待。</li>
<li>wait操作：执行wait操作的进程进入条件变量链末尾，唤醒紧急等待队列或者入口队列中的进程；signal操作：唤醒条件变量链中的进程，自己进入紧急等待队列，若条件变量链为空，则继续执行。</li>
</ul>
</li>
<li>MESA管程：<ul>
<li>将HOARE中的signal换成了notify（或者broadcast通知所有满足条件的），进行通知而不是立马交换管程的使用权，在合适的时候，条件队列首位的进程可以进入，进入之前必须用while检查条件是否合适。</li>
<li>优点：没有额外的进程切换</li>
</ul>
</li>
</ul>
<h3 id="Linux线程同步有哪些方式？"><a href="#Linux线程同步有哪些方式？" class="headerlink" title="Linux线程同步有哪些方式？"></a>Linux线程同步有哪些方式？</h3><h4 id="1-互斥锁-mutex"><a href="#1-互斥锁-mutex" class="headerlink" title="1.互斥锁(mutex):"></a>1.互斥锁(mutex):</h4><ul>
<li>锁机制是同一时刻只允许一个线程访问临界区/临界资源. 强调的是资源的访问互斥</li>
<li>互斥锁必须总是由给它上锁的线程解锁.</li>
<li>互斥锁只有”锁住”和”解开”两种转态.</li>
<li>Linux中, 线程的互斥量数据类型是<code>pthread_mutex_t</code>. 在使用前, 要使用<code>pthread_mutex_init()</code>进行初始化; 使用<code>pthread_mutex_lock()</code>(阻塞)或<code>pthread_mutex_trylock()</code>(非阻塞) 进行加锁; 使用<code>pthread_mutex_unlock()</code>进行解锁; 使用<code>pthread_mutex_destroy()</code>销毁锁.<h4 id="2-条件变量-cond"><a href="#2-条件变量-cond" class="headerlink" title="2.条件变量(cond)"></a>2.条件变量(cond)</h4></li>
<li>条件变量是利用线程间共享全局变量进行<strong>同步</strong>的一种机制。</li>
<li>条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。</li>
<li>Linux中使用<code>pthread_cond_init()</code>初始化条件变量, 使用<code>pthread_cond_wait()</code>或<code>pthread_cond_timewait</code>进行无条件等待或计时等待. 使用<code>pthread_cond_signal()</code>激活条件变量解除线程的阻塞, 使用<code>pthread_cond_broadcast</code>激活所有等待线程</li>
<li>必须和一个互斥锁配合，以防止多个线程同时请求竞争条件（Race Condition）. 且在等待前须有本线程加锁（pthread_mutex_lock()）</li>
</ul>
<h4 id="3-读写锁"><a href="#3-读写锁" class="headerlink" title="3.读写锁"></a>3.读写锁</h4><ul>
<li><p>与互斥锁类似. 但读写锁可以有三种状态：读模式下加锁状态，写模式下加锁状态，不加锁状态。一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。</p>
</li>
<li><p>当读写锁以读模式锁住时，它是以共享模式锁住的；当他以写模式锁住时，它是以独占模式锁住的。读读共享，读写互斥.</p>
</li>
<li><p>写模式加锁优先. 当读写锁处于读模式锁住状态时，如果有另外的线程试图以写模式加锁，读写锁通常会阻塞随后的读模式锁请求</p>
</li>
<li><p>可用于解决读者-写者问题.</p>
</li>
<li><p>Linux中, 使用<code>pthread_rwlock_init()</code>初始化读写锁. 使用<code>pthread_rwlock_rdlock()</code>加读锁，使用<code>pthread_rwlock_wrlock()</code>加写锁, 使用<code>pthread_rwlock_unlock()</code>释放读锁或者写锁</p>
<h4 id="4-信号量"><a href="#4-信号量" class="headerlink" title="4.信号量"></a>4.信号量</h4></li>
<li><p>轻量级信号量可用于线程间的同步与互斥. (信号量也可用于进程间同步与互斥)</p>
</li>
<li><p>Linux中使用<code>sem_init()</code>初始化信号量; <code>sem_wait()</code>相当于P操作, 信号量-1; <code>sem_post()</code>相当于V操作, 信号量+1, <code>sem_destory()</code>销毁信号量</p>
</li>
</ul>
<h3 id="什么是协程？"><a href="#什么是协程？" class="headerlink" title="什么是协程？"></a>什么是协程？</h3><ul>
<li>协程是一种<strong>用户态的轻量级线程</strong>，协程的<strong>调度完全由用户控制</strong>, 非抢占式.</li>
<li>协程拥<strong>有自己的寄存器上下文和栈</strong>。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈</li>
<li>协程<strong>能保留上一次调用时的状态</strong>（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，</li>
<li>协程是<strong>基于线程实现</strong>的，协程的创建、切换、销毁都是在某个线程中来进行的. <strong>一个线程可以包含多个协程</strong>.</li>
<li>协程的好处: <ul>
<li><strong>无需用户态到核态的转换</strong>, 寄存器需要保存和加载的数据量比较小, 因此<strong>切换速度快, 开销小</strong></li>
<li><strong>不需要多线程的锁机制</strong>，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态. <strong>协程的切换时机是开发者可控可知的</strong>, 因此无需互斥同步机制; 但也可以实现.</li>
<li>方便切换控制流，简化编程模型</li>
<li><strong>资源占用小</strong>, 初始一般为2KB, 可随需要增大</li>
</ul>
</li>
</ul>
<h3 id="协程与线程进行比较"><a href="#协程与线程进行比较" class="headerlink" title="协程与线程进行比较"></a>协程与线程进行比较</h3><details>
<summary>展开</summary>

<ol>
<li><strong>一个线程可以拥有多个协程</strong>，多协程也可用在多进程上运行</li>
<li>线程进程都是同步机制，而协程则是异步</li>
<li>协程<strong>能保留上一次调用时的状态</strong>，每次过程重入时，就相当于进入上一次调用的状态</li>
<li>协程占用资源比线程小</li>
<li>线程切换需要用户态和核态的转换, 而协程间切换无需用户态到核态的转换,换速度快更快, 开销更小</details>

</li>
</ol>
<h3 id="什么是IO多路复用？怎么实现？"><a href="#什么是IO多路复用？怎么实现？" class="headerlink" title="什么是IO多路复用？怎么实现？"></a>什么是IO多路复用？怎么实现？</h3><ul>
<li>IO多路复用（IO Multiplexing）是一种同步IO模型，<strong>实现单线程或单线程可以监视多个文件描述符；一旦某个描述符就绪，就能够通知程序进行相应的读写操作</strong>；没有文件描述符就绪时会阻塞应用程序，交出cpu。</li>
<li>实现原理：用户<strong>将想要监视的文件描述符（File Descriptor）添加到select/poll/epoll函数</strong>中，由<strong>内核监视</strong>，函数阻塞。一旦<strong>有文件描述符就绪</strong>（读就绪或写就绪），或者超时（设置timeout），函数就会返回，然后<strong>该进程可以进行相应的读/写操作</strong>。</li>
</ul>
<h3 id="select-poll-epoll及其区别"><a href="#select-poll-epoll及其区别" class="headerlink" title="select/poll/epoll及其区别"></a>select/poll/epoll及其区别</h3><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds,</span></span></span><br><span class="line"><span class="function"><span class="params">            fd_set *<span class="keyword">restrict</span> readfds,</span></span></span><br><span class="line"><span class="function"><span class="params">            fd_set *<span class="keyword">restrict</span> writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">            fd_set *<span class="keyword">restrict</span> errorfds,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct timeval *<span class="keyword">restrict</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>readfds</code>、<code>writefds</code>、<code>errorfds</code> 是三个文件描述符集合。select 会遍历每个集合的前 <code>nfds</code> 个描述符，分别找到可以读取、可以写入、发生错误的描述符，统称为“就绪”的描述符。然后用找到的子集替换参数中的对应集合，返回所有就绪描述符的总数。<code>timeout</code> 参数表示调用 select 时的阻塞时长。如果所有文件描述符都未就绪，就阻塞调用进程，<strong>直到某个描述符就绪，或者阻塞超过设置的 timeout 后，返回</strong>。如果 timeout 参数设为 NULL，会无限阻塞直到某个描述符就绪；如果 timeout 参数设为 0，会立即返回，不阻塞。</li>
<li>将文件描述符放入一个文件描述符集合<code>fd_set</code>中，每次调用select时，都将这个集合从用户空间拷贝到内核空间（缺点1：每次都要复制，<strong>开销大</strong>）由内核根据就绪状态修改该集合的内容。</li>
<li>文件描述符<strong>集合大小有限制</strong>（缺点2），导致同时能够监听的文件描述符数量太少, 32位机默认是1024（64位：2048）；采用水平触发机制。</li>
<li>select函数每次调用，需要通过遍历这个集合，找到就绪的文件描述符（缺点3：<strong>轮询的方式效率较低</strong>），当文件描述符的数量增加时，效率会线性下降；<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">( struct pollfd * fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>和select几乎没有区别，区别在于文件描述符的存储方式不同，<strong>poll采用链表的方式存储文件描述符，没有最大存储数量的限制</strong>；</li>
<li>和select同样都是通过轮询的方式来查询某个文件描述符状态是否发生了变化，并且需要将整个文件描述符集合在用户空间和内核空间之间来回拷贝<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>使用红黑树存储文件描述符集合, 使用队列存储就绪的文件描述符</li>
<li> epoll 对于每个描述符，只需要在 epoll_ctl 传递一次，之后 epoll_wait 不需要再次传递；通过事件更改文件描述符状态</li>
<li>epoll由事件驱动, epoll_ctl 中为每个文件描述符指定了回调函数，并在就绪时将其加入到就绪列表, 避免了轮询</li>
<li>支持水平触发和边缘触发. 采用边缘触发机制时，只有活跃的描述符才会触发回调函数。减少了事件被重复触发的次数.</li>
<li>通过内核和用户空间共享内存，避免了不断复制的问题；</li>
<li>支持的同时连接数上限很高（1G左右的内存支持10W左右的连接数）；</li>
</ul>
<p>总结，区别主要在于：</p>
<ul>
<li>一个线程/进程所能打开的最大连接数</li>
<li>文件描述符传递方式（是否复制）</li>
<li>水平触发 or 边缘触发</li>
<li>查询就绪的描述符时的效率（是否轮询）</details>

</li>
</ul>
<details>
<summary>什么时候使用select/poll，什么时候使用epoll？</summary>

<p>当连接数较多并且有很多的不活跃连接时，epoll的效率比其它两者高很多；但是当连接数较少并且都十分活跃的情况下，由于epoll需要很多回调，因此性能可能低于其它两者。</p>
</details>

<details>
<summary>什么是文件描述符？</summary>

<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p>
<p>内核通过文件描述符来访问文件。文件描述符指向一个文件。</p>
</details>

<h5 id="什么是水平触发？什么是边缘触发？"><a href="#什么是水平触发？什么是边缘触发？" class="headerlink" title="什么是水平触发？什么是边缘触发？"></a>什么是水平触发？什么是边缘触发？</h5><details>
<summary>展开</summary>

<ul>
<li>水平触发（LT，Level Trigger）模式下，只要一个文件描述符就绪，就会触发通知，如果用户程序没有一次性把数据读写完，下次还会通知；</li>
<li>边缘触发（ET，Edge Trigger）模式下，当描述符从未就绪变为就绪时通知一次，之后不会再通知，直到再次从未就绪变为就绪（缓冲区从不可读/写变为可读/写）。</li>
<li>区别：边缘触发效率更高，减少了被重复触发的次数，函数不会返回大量用户程序可能不需要的文件描述符。</li>
<li>为什么边缘触发一定要用非阻塞（non-block）IO：避免由于一个描述符的阻塞读/阻塞写操作让处理其它描述符的任务出现饥饿状态。</details>

</li>
</ul>
<h5 id="有哪些常见的IO模型？"><a href="#有哪些常见的IO模型？" class="headerlink" title="有哪些常见的IO模型？"></a>有哪些常见的IO模型？</h5><details>
<summary>展开</summary>

<ul>
<li>同步阻塞IO（Blocking IO）：用户线程发起IO读/写操作之后，线程阻塞，直到可以开始处理数据；对CPU资源的利用率不够；</li>
<li>同步非阻塞IO（Non-blocking IO）：发起IO请求之后可以立即返回，如果没有就绪的数据，需要不断地发起IO请求直到数据就绪；不断重复请求消耗了大量的CPU资源；</li>
<li>IO多路复用</li>
<li>异步IO（Asynchronous IO）：用户线程发出IO请求之后，继续执行，由内核进行数据的读取并放在用户指定的缓冲区内，在IO完成之后通知用户线程直接使用。</details>

</li>
</ul>
<h3 id="什么是用户态和内核态？"><a href="#什么是用户态和内核态？" class="headerlink" title="什么是用户态和内核态？"></a>什么是用户态和内核态？</h3><p>为了限制不同程序的访问能力，防止一些程序访问其它程序的内存数据，CPU划分了用户态和内核态两个权限等级。</p>
<ul>
<li>用户态只能受限地访问内存，且不允许访问外围设备，没有占用CPU的能力，CPU资源可以被其它程序获取；</li>
<li>内核态可以访问内存所有数据以及外围设备，也可以进行程序的切换。</li>
</ul>
<p>所有用户程序都运行在用户态，但有时需要进行一些内核态的操作，比如从硬盘或者键盘读数据，这时就需要进行系统调用，使用<strong>陷阱指令</strong>，CPU切换到内核态，执行相应的服务，再切换为用户态并返回系统调用的结果。</p>
<h5 id="为什么要分用户态和内核态？"><a href="#为什么要分用户态和内核态？" class="headerlink" title="为什么要分用户态和内核态？"></a>为什么要分用户态和内核态？</h5><details>
<summary>展开</summary>

<p>（我自己的见解：）</p>
<ul>
<li>安全性：防止用户程序恶意或者不小心破坏系统/内存/硬件资源；</li>
<li>封装性：用户程序不需要实现更加底层的代码；</li>
<li>利于调度：如果多个用户程序都在等待键盘输入，这时就需要进行调度；统一交给操作系统调度更加方便。</details>

</li>
</ul>
<h5 id="如何从用户态切换到内核态？"><a href="#如何从用户态切换到内核态？" class="headerlink" title="如何从用户态切换到内核态？"></a>如何从用户态切换到内核态？</h5><details>
<summary>展开</summary>

<ul>
<li>系统调用：比如读取命令行输入。本质上还是通过中断实现</li>
<li>用户程序发生异常时：比如缺页异常</li>
<li>外围设备的中断：外围设备完成用户请求的操作之后，会向CPU发出中断信号，这时CPU会转去处理对应的中断处理程序</details>

</li>
</ul>
<hr>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h3><p>在两个或者多个并发进程中，每个进程持有某种资源而又等待其它进程释放它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁(deadlock)。</p>
<h3 id="死锁产生的必要条件？"><a href="#死锁产生的必要条件？" class="headerlink" title="死锁产生的必要条件？"></a>死锁产生的必要条件？</h3><ul>
<li><strong>互斥</strong>：一个资源一次只能被一个进程使用；</li>
<li><strong>占有并等待</strong>：一个进程至少占有一个资源，并在等待另一个被其它进程占用的资源；</li>
<li><strong>非抢占</strong>：已经分配给一个进程的资源不能被强制性抢占，只能由进程完成任务之后自愿释放；</li>
<li><strong>循环等待</strong>：若干进程之间形成一种头尾相接的环形等待资源关系，该环路中的每个进程都在等待下一个进程所占有的资源。</li>
</ul>
<h3 id="死锁有哪些处理方法？"><a href="#死锁有哪些处理方法？" class="headerlink" title="死锁有哪些处理方法？"></a>死锁有哪些处理方法？</h3><details>
<summary>鸵鸟策略</summary>

<p>直接忽略死锁。因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p>
</details>

<details>
<summary>死锁预防</summary>

<p>基本思想是破坏形成死锁的四个必要条件：</p>
<ul>
<li>破坏互斥条件：允许某些资源同时被多个进程访问。但是有些资源本身并不具有这种属性，因此这种方案实用性有限；</li>
<li>破坏占有并等待条件：<ul>
<li>实行资源预先分配策略（当一个进程开始运行之前，必须一次性向系统申请它所需要的全部资源，否则不运行）；</li>
<li>或者只允许进程在没有占用资源的时候才能申请资源（申请资源前先释放占有的资源）；</li>
<li>缺点：很多时候无法预知一个进程所需的全部资源；同时，会降低资源利用率，降低系统的并发性；</li>
</ul>
</li>
<li>破坏非抢占条件：允许进程强行抢占被其它进程占有的资源。会降低系统性能；</li>
<li>破坏循环等待条件：对所有资源统一编号，所有进程对资源的请求必须按照序号递增的顺序提出，即只有占有了编号较小的资源才能申请编号较大的资源。这样避免了占有大号资源的进程去申请小号资源。</details>

</li>
</ul>
<details>
<summary>死锁避免</summary>

<p>动态地检测资源分配状态，以确保系统处于安全状态，只有处于安全状态时才会进行资源的分配。所谓安全状态是指：即使所有进程突然请求需要的所有资源，也能存在某种对进程的资源分配顺序，使得每一个进程运行完毕。</p>
<blockquote>
<p>银行家算法</p>
</blockquote>
</details>

<details>
<summary>死锁解除</summary>

<blockquote>
<p>如何检测死锁：检测有向图是否存在环；或者使用类似死锁避免的检测算法。</p>
</blockquote>
<p>死锁解除的方法：</p>
<ul>
<li>利用抢占：挂起某些进程，并抢占它的资源。但应防止某些进程被长时间挂起而处于饥饿状态；</li>
<li>利用回滚：让某些进程回退到足以解除死锁的地步，进程回退时自愿释放资源。要求系统保持进程的历史信息，设置还原点；</li>
<li>利用杀死进程：强制杀死某些进程直到死锁解除为止，可以按照优先级进行。</details>

</li>
</ul>
<hr>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="分页和分段有什么区别？"><a href="#分页和分段有什么区别？" class="headerlink" title="分页和分段有什么区别？"></a>分页和分段有什么区别？</h3><ul>
<li>页式存储：用户空间划分为大小相等的部分称为页（page），内存空间划分为同样大小的区域称为页框，分配时以页为单位，按进程需要的页数分配，逻辑上相邻的页物理上不一定相邻；</li>
<li>段式存储：用户进程地址空间按照自身逻辑关系划分为若干个段（segment）（如代码段，数据段，堆栈段），内存空间被动态划分为长度不同的区域，分配时以段为单位，每段在内存中占据连续空间，各段可以不相邻；</li>
<li>段页式存储：用户进程先按段划分，段内再按页划分，内存划分和分配按页。</li>
</ul>
<p>区别：</p>
<ul>
<li>目的不同：分页的目的是管理内存，用于虚拟内存以获得更大的地址空间；分段的目的是满足用户的需要，使程序和数据可以被划分为逻辑上独立的地址空间；</li>
<li>大小不同：段的大小不固定，由其所完成的功能决定；页的大小固定，由系统决定；</li>
<li>地址空间维度不同：分段是二维地址空间（段号+段内偏移），分页是一维地址空间（每个进程一个页表/多级页表，通过一个逻辑地址就能找到对应的物理地址）；</li>
<li>分段便于信息的保护和共享；分页的共享收到限制；</li>
<li>碎片：分段没有内碎片，但会产生外碎片；分页没有外碎片，但会产生内碎片（一个页填不满）</li>
</ul>
<h3 id="什么是虚拟内存？"><a href="#什么是虚拟内存？" class="headerlink" title="什么是虚拟内存？"></a>什么是虚拟内存？</h3><p>每个程序都拥有自己的地址空间，这个地址空间被分成大小相等的页，这些页被映射到物理内存；但不需要所有的页都在物理内存中，当程序引用到不在物理内存中的页时，由操作系统将缺失的部分装入物理内存。这样，对于程序来说，逻辑上似乎有很大的内存空间，只是实际上有一部分是存储在磁盘上，因此叫做虚拟内存。</p>
<p>虚拟内存的优点是让程序可以获得更多的可用内存。</p>
<h5 id="如何进行地址空间到物理内存的映射？"><a href="#如何进行地址空间到物理内存的映射？" class="headerlink" title="如何进行地址空间到物理内存的映射？"></a>如何进行地址空间到物理内存的映射？</h5><details>
<summary>展开</summary>

<p><strong>内存管理单元</strong>（MMU）管理着逻辑地址和物理地址的转换，其中的页表（Page table）存储着页（逻辑地址）和页框（物理内存空间）的映射表，页表中还包含包含有效位（是在内存还是磁盘）、访问位（是否被访问过）、修改位（内存中是否被修改过）、保护位（只读还是可读写）。逻辑地址：页号+页内地址（偏移）；每个进程一个页表，放在内存，页表起始地址在PCB/寄存器中。</p>
</details>

<h3 id="有哪些页面置换算法？"><a href="#有哪些页面置换算法？" class="headerlink" title="有哪些页面置换算法？"></a>有哪些页面置换算法？</h3><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘中来腾出空间。页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p>
<ul>
<li><strong>最佳页面置换算法</strong>OPT（Optimal replacement algorithm）：置换以后不需要或者最远的将来才需要的页面，是一种理论上的算法，是最优策略；</li>
<li><strong>先进先出</strong>FIFO：置换在内存中驻留时间最长的页面。缺点：有可能将那些经常被访问的页面也被换出，从而使缺页率升高；</li>
<li><strong>第二次机会算法</strong>SCR：按FIFO选择某一页面，若其访问位为1，给第二次机会，并将访问位置0；</li>
<li><strong>时钟算法</strong> Clock：SCR中需要将页面在链表中移动（第二次机会的时候要将这个页面从链表头移到链表尾），时钟算法使用环形链表，再使用一个指针指向最老的页面，避免了移动页面的开销；</li>
<li><strong>最近未使用算法</strong>NRU（Not Recently Used）：检查访问位R、修改位M，优先置换R=M=0，其次是（R=0, M=1）；</li>
<li><strong>最近最少使用算法</strong>LRU（Least Recently Used）：置换出未使用时间最长的一页；实现方式：维护时间戳，或者维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</li>
<li><strong>最不经常使用算法</strong>NFU：置换出访问次数最少的页面</li>
</ul>
<details>
<summary>局部性原理</summary>

<ul>
<li>时间上：最近被访问的页在不久的将来还会被访问；</li>
<li>空间上：内存中被访问的页周围的页也很可能被访问。</details>

</li>
</ul>
<details>
<summary>什么是颠簸现象</summary>

<p>颠簸本质上是指频繁的页调度行为。进程发生缺页中断时必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸。内存颠簸的解决策略包括：</p>
<ul>
<li>修改页面置换算法；</li>
<li>降低同时运行的程序的数量；</li>
<li>终止该进程或增加物理内存容量。</details>

</li>
</ul>
<h3 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h3><p>过程：磁头（找到对应的盘面）；磁道（一个盘面上的同心圆环，寻道时间）；扇区（旋转时间）。为减小寻道时间的调度算法：</p>
<ul>
<li>先来先服务</li>
<li>最短寻道时间优先</li>
<li>电梯算法：电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.jianshu.com/p/c1015f5ffa74">进程间通信IPC – 简书</a></li>
<li><a href="https://blog.csdn.net/justloveyou_/article/details/78304294">面试/笔试第二弹 —— 操作系统面试问题集锦 - CSDN博客</a></li>
<li><a href="https://segmentfault.com/a/1190000018970361">线程同步与并发 - - SegmentFault</a></li>
<li><a href="http://baijiahao.baidu.com/s?id=1641172494287388070&wfr=spider&for=pc">彻底搞懂epoll高效运行的原理</a></li>
<li><a href="https://www.cnblogs.com/lirong21/p/4213028.html">用户态与内核态的切换</a></li>
</ul>
<h3 id="待完成"><a href="#待完成" class="headerlink" title="待完成"></a>待完成</h3><ul>
<li><input disabled="" type="checkbox"> IPC</li>
<li><input disabled="" type="checkbox"> 进程同步问题：生产者-消费者问题…</li>
<li><input disabled="" type="checkbox"> 银行家算法</li>
<li><input disabled="" type="checkbox"> 文件与文件系统、文件管理？<div>
<img src="_v_images/20191202162008435_14938.png" width=540px></img>
</div>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2021/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><hr>
<h2 id="传输层：TCP和UDP"><a href="#传输层：TCP和UDP" class="headerlink" title="传输层：TCP和UDP"></a>传输层：TCP和UDP</h2><h3 id="什么是三次握手-three-way-handshake"><a href="#什么是三次握手-three-way-handshake" class="headerlink" title="什么是三次握手 (three-way handshake)?"></a>什么是三次握手 (three-way handshake)?</h3><p>![TCP状态图](<a href="https://www.hoohack.me/assets/images/2018/09/tcp-classic.png">https://www.hoohack.me/assets/images/2018/09/tcp-classic.png</a> =550x)<br><img src="_v_images/20191129101827556_21212.png" alt="三次握手"></p>
<details>
<summary>展开</summary>

<h4 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h4><ul>
<li>Client(主动打开)将<strong>SYN(同步比特)置1</strong>,<strong>随机产生一个初始序列号(ISN) seq=J</strong>发送给Server,</li>
<li><strong>无应用层数据</strong>, 客户端进入SYN_SENT状态; <h4 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h4></li>
<li>Server收到Client的SYN=1的报文段之后, 知道客户端请求建立连接, </li>
<li>将自己的<strong>SYN置1, ACK(确认比特)置1, 产生一个ack(确认号)=seq(序列号)+1=J+1</strong>, 并<strong>随机产生一个自己的初始序列号seq=K</strong>, 发送给客户端; </li>
<li>服务端进入SYN_RCVD状态</li>
<li>发送后服务端分配资源, 直到超时才释放资源<h4 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h4></li>
<li>客户端检查收到报文段的ack(确认号)是否为序列号J+1, ACK是否为1.</li>
<li>检查正确之后分配资源. 将自己的<strong>ACK置为1, 产生一个确认号ack=K+1</strong>, 发送给服务器; 客户端进入ESTABLISHED状态; </li>
<li>第三次握手客户端发送的报文段可以携带数据, 也可不带</li>
<li>服务器检查ACK为1和ack为序列号K+1之后, 也进入ESTABLISHED状态; 完成三次握手, 连接建立. </details>

</li>
</ul>
<h3 id="TCP建立连接可以两次握手吗-为什么"><a href="#TCP建立连接可以两次握手吗-为什么" class="headerlink" title="TCP建立连接可以两次握手吗? 为什么?"></a>TCP建立连接可以两次握手吗? 为什么?</h3><details>
<summary>展开</summary>

<p><strong>不可以</strong>. </p>
<ul>
<li>TCP是双向通信, 两次握手只能确保一个方向建立连接, <strong>Server无法确认Client是否收到第二次握手的报文段</strong>, 也<strong>无法保证Client和Server之间成功互换初始序列号</strong>.</li>
<li>可能会出现<strong>已失效的连接请求报文段又传到了服务器端</strong>. client 发出的第一个连接请求报文段并没有丢失, 而是在某个网络结点长时间的滞留了, 以致延误到连接释放以后的某个时间才到达 server. 本来这是一个早已失效的报文段(<strong>客户端连接释放后客户端才收到已经失效的连接请求</strong>). 但server 收到此失效的连接请求报文段后, 就误认为是 client 再次发出的一个新的连接请求. 于是<strong>Server就向 client 发出确认报文段, 同意建立连接</strong>. 假设<strong>不采用 “三次握手”, 那么只要 server 发出确认, 新的连接就建立了</strong>. 由于现在<strong>client 并没有发出建立连接的请求, 因此不会理睬 server 的确认, 也不会向 server 发送数据. 但 server 却以为新的运输连接已经建立, 并一直等待 client 发来数据</strong>. 这样, server 的很多资源就白白浪费掉了. 采用 “三次握手” 的办法可以防止上述现象发生. 例如刚才那种情况, client 不会向 server 的确认发出确认. server 由于收不到确认, 就知道 client 并没有要求建立连接. </li>
<li>如果客户端的 SYN 阻塞了, 重复发送多次 SYN 报文, 那么<strong>服务器在收到请求后就会建立多个冗余的无效链接, 造成不必要的资源浪费</strong>.</li>
</ul>
</details>

<h3 id="可以采用四次握手吗-为什么"><a href="#可以采用四次握手吗-为什么" class="headerlink" title="可以采用四次握手吗? 为什么?"></a>可以采用四次握手吗? 为什么?</h3><details>
<summary>展开</summary>

<p><strong>可以. 但是会降低传输的效率</strong>.<br>四次握手是指：<strong>第二次握手：Server只发送ACK(确认比特)和acknowledge number(确认序列号); 而Server的SYN和初始序列号(seq=k)在第三次握手时发送; 原来协议中的第三次握手变为第四次握手</strong>. 出于优化目的, 四次握手中的二、三可以合并. </p>
</details>

<h3 id="第三次握手中-如果客户端的ACK未送达服务器-会怎样"><a href="#第三次握手中-如果客户端的ACK未送达服务器-会怎样" class="headerlink" title="第三次握手中, 如果客户端的ACK未送达服务器, 会怎样?"></a>第三次握手中, 如果客户端的ACK未送达服务器, 会怎样?</h3><details>
<summary>展开</summary>

<ul>
<li>Server端：  </li>
</ul>
<ol>
<li>由于Server没有收到ACK确认, 因此会<strong>重发之前的SYN+ACK(第二次握手的报文段), 默认重发五次, 之后自动关闭连接进入CLOSED状态</strong>关闭连接, Client收到后会重新传ACK给Server. </li>
<li>在Server进行超时重发的过程中, 如果服务器收到客户端第三次挥手报文, 进入establish 状态建立连接.</li>
<li><strong>Server此时为SYN_RCVD状态</strong>,而不是ESTABLISHED状态, 若<strong>收到Client发送的数据, 服务器会以RST包应答</strong>(RST=1复位比特, 需要释放连接重新建立). </li>
</ol>
<ul>
<li>Client端:<br>由于客户端在收到第二次握手的报文后就进入了ESTABLISH 状态, 认为连接已经建立, 因此发送第三次握手的报文后就可以向服务端发送数据.<br>如果第三次握手中的ACK包丢失的情况下, Client 向 server端发送数据, Server端将以RST包响应, 客户端Client便能感知到Server的错误. </details>

</li>
</ul>
<h3 id="如果已经建立了连接-但客户端出现了故障怎么办"><a href="#如果已经建立了连接-但客户端出现了故障怎么办" class="headerlink" title="如果已经建立了连接, 但客户端出现了故障怎么办?"></a>如果已经建立了连接, 但客户端出现了故障怎么办?</h3><details>
<summary>展开</summary>

<p>服务器<strong>每收到一次客户端的请求后都会重新复位一个保活计时器</strong>, 时间通常是设置为2小时, 若两小时还没有收到客户端的任何数据, 服务器就会<strong>发送一个探测报文段, 以后每隔75秒钟发送一次. 若一连发送10个</strong>探测报文仍然没反应, 服务器就认为客户端出了故障, 接着就关闭连接. </p>
</details>

<h3 id="初始序列号是什么"><a href="#初始序列号是什么" class="headerlink" title="初始序列号是什么?"></a>初始序列号是什么?</h3><details>
<summary>展开</summary>

<ul>
<li>TCP连接的一方A, <strong>随机选择一个32位的序列号</strong>(Sequence Number)作为发送数据的初始序列号(Initial Sequence Number, ISN), 比如为1000, </li>
<li>以该序列号为原点, 对要传送的数据(每一个字节)进行编号：1001、1002… </li>
<li>三次握手时, 把这个初始序列号传送给另一方B(第一次握手客户端-&gt;服务端, 第二次握手服务端-&gt;客户端)</li>
<li>以便在传输数据时, B可以确认什么样的数据编号是合法的; 同时在进行数据传输时, A还可以确认B收到的每一个字节, 如果A收到了B的确认编号(acknowledge number)是2001, 就说明编号为1001-2000的数据已经被B成功接受. </details>

</li>
</ul>
<hr>
<h3 id="什么是四次挥手"><a href="#什么是四次挥手" class="headerlink" title="什么是四次挥手?"></a>什么是四次挥手?</h3><p><img src="_v_images/20191129112652915_15481.png" alt="四次挥手"></p>
<details>
<summary>展开</summary>

<h4 id="第一次挥手"><a href="#第一次挥手" class="headerlink" title="第一次挥手"></a>第一次挥手</h4><ul>
<li>Client将<strong>FIN(终止比特)置为1</strong>, 发送一个序列号seq=M 给Server; </li>
<li>进入FIN_WAIT_1状态; <h4 id="第二次挥手"><a href="#第二次挥手" class="headerlink" title="第二次挥手"></a>第二次挥手</h4></li>
<li>Server收到FIN之后, 发送一个<strong>ACK=1, ack(确认号)=收到的序列号M+1</strong>的报文段; 进入CLOSE_WAIT状态. </li>
<li>此时客户端已经没有要发送的数据了, 但仍可以接受服务器发来的数据</li>
<li>客户端收到服务端第二次挥手的报文段后进入FIN_WAIT_2状态<h4 id="第三次挥手"><a href="#第三次挥手" class="headerlink" title="第三次挥手"></a>第三次挥手</h4></li>
<li>Server将<strong>FIN置1, 发送一个序列号seq=N</strong>给Client; </li>
<li>服务端进入LAST_ACK状态; <h4 id="第四次挥手"><a href="#第四次挥手" class="headerlink" title="第四次挥手"></a>第四次挥手</h4></li>
<li>Client收到服务器的FIN后, 进入TIME_WAIT状态; </li>
<li>接着将<strong>ACK置1, 发送一个ack=序列号N+1</strong>给服务器; </li>
<li>服务器收到后, 确认ack后, 变为CLOSED状态, 不再向客户端发送数据. </li>
<li>客户端<strong>等待2×MSL(最大报文生存期)时间后</strong>, 也进入CLOSED状态. 完成四次挥手. </details>

</li>
</ul>
<h3 id="为什么不能把服务器发送的ACK和FIN合并起来-变成三次挥手-CLOSE-WAIT状态意义是什么"><a href="#为什么不能把服务器发送的ACK和FIN合并起来-变成三次挥手-CLOSE-WAIT状态意义是什么" class="headerlink" title="为什么不能把服务器发送的ACK和FIN合并起来, 变成三次挥手(CLOSE_WAIT状态意义是什么)?"></a>为什么不能把服务器发送的ACK和FIN合并起来, 变成三次挥手(CLOSE_WAIT状态意义是什么)?</h3><details>
<summary>展开</summary>

<ul>
<li>因为服务器收到客户端断开连接的请求时, <strong>服务端可能还有一些数据没有发完</strong>, 这时先回复ACK, 表示接收到了断开连接的请求. </li>
<li><strong>等到数据发完之后再发FIN</strong>, 断开服务器到客户端的数据传送. </details>

</li>
</ul>
<h3 id="如果第二次挥手时服务器的ACK没有送达客户端-会怎样"><a href="#如果第二次挥手时服务器的ACK没有送达客户端-会怎样" class="headerlink" title="如果第二次挥手时服务器的ACK没有送达客户端, 会怎样?"></a>如果第二次挥手时服务器的ACK没有送达客户端, 会怎样?</h3><details>
<summary>展开</summary>

<p><strong>客户端</strong>没有收到ACK确认, 会<strong>重新发送FIN(断开连接)请求</strong>. </p>
</details>

<h3 id="客户端TIME-WAIT状态的意义是什么"><a href="#客户端TIME-WAIT状态的意义是什么" class="headerlink" title="客户端TIME_WAIT状态的意义是什么?"></a>客户端TIME_WAIT状态的意义是什么?</h3><details>
<summary>展开</summary>

<ul>
<li><strong>实现TCP全双工连接的可靠释放</strong>: <ul>
<li>第四次挥手时, <strong>客户端发送给服务器的ACK(第四次挥手)有可能丢失</strong>, TIME_WAIT状态就是<strong>用来重发可能丢失的ACK报文</strong>. </li>
<li>如果Server没有收到ACK(第四次挥手报文段), 就会重发FIN, 如果Client在2×MSL(最大报文段生存期)的时间内收到了FIN, 就会<strong>重新发送ACK并再次等待2MSL, 防止Server没有收到ACK而不断重发FIN</strong>. </li>
<li>如果直到2MSL, Client都没有再次收到FIN, 那么Client推断ACK已经被成功接收, 则结束TCP连接. </li>
</ul>
</li>
<li><strong>保证迟来的TCP报文段有足够的时间被识别并丢弃</strong>.<ul>
<li>若一条连接先关闭关闭紧接着用相同的四元组建立一条新连接, 则旧连接中延迟到达的TCP报文段可能会作为新连接的数据.</li>
<li>TIME_WAIT阶段TCP<strong>不能再建立一条相同的连接</strong>, 能保证所有旧连接的旧数据能够被丢弃</li>
</ul>
</li>
<li>MSL(Maximum Segment Lifetime): 最大报文段生存期, 指一个片段在网络中最大的存活时间, 2MSL就是一个发送和一个回复所需的最大时间. <ul>
<li>一个MSL是确保主动关闭方最后的ACK能够到达对端。</li>
<li>一个MSL是确保被动关闭方重发的FIN能够被主动关闭方收到。</li>
</ul>
</li>
</ul>
</details>

<h3 id="TCP如何实现流量控制"><a href="#TCP如何实现流量控制" class="headerlink" title="TCP如何实现流量控制?"></a>TCP如何实现流量控制?</h3><p>![滑动窗口](_v_images/20191129145400104_2106.png =600x)</p>
<details>
<summary>展开</summary>

<ul>
<li>使用<strong>滑动窗口协议实现流量控制</strong>. 防止发送方发送速率太快, 接收方缓存区不够导致溢出. </li>
<li>接收方会维护一个接收窗口 receiver window(窗口大小单位是字节), 接受窗口的大小是根据自己的资源情况动态调整的.</li>
<li>RcvWindows = RcvBuffer - (LastByteRcvd - LastByteRead) = 接收缓存大小 - (最后收到字节的编号 - 最后读取字节的编号) = 接收缓存大小 - 缓存中的TCP数据</li>
<li>在返回ACK时<strong>将接受窗口大小放在TCP报文中的窗口字段</strong>告知发送方. <strong>发送窗口的大小不能超过接受窗口的大小</strong>, 只有当发送方发送并收到确认之后, 才能将发送窗口右移. </li>
<li><strong>发送窗口的上限为接受窗口和拥塞窗口中的较小值</strong>. 接受窗口表明了接收方的接收能力, 拥塞窗口表明了网络的传送能力. </details>

</li>
</ul>
<h3 id="什么是零窗口-接收窗口为0时会怎样"><a href="#什么是零窗口-接收窗口为0时会怎样" class="headerlink" title="什么是零窗口(接收窗口为0时会怎样)?"></a>什么是零窗口(接收窗口为0时会怎样)?</h3><details>
<summary>展开</summary>

<ul>
<li>如果接收方没有能力接收数据, 就会将接收窗口设置为0.</li>
<li>这时发送方必须暂停发送数据, 但是会<strong>启动一个持续计时器</strong>(persistence timer), 到期后发送一个<strong>大小为1字节的探测数据包</strong>, 以查看接收窗口状态. 如果接收方能够接收数据, 就会<strong>在返回的报文中更新接收窗口大小</strong>, 恢复数据传送. </details>

</li>
</ul>
<h3 id="TCP的拥塞控制是怎么实现的"><a href="#TCP的拥塞控制是怎么实现的" class="headerlink" title="TCP的拥塞控制是怎么实现的?"></a>TCP的拥塞控制是怎么实现的?</h3><p><img src="_v_images/20191129153624025_28293.png" alt="拥塞控制"></p>
<details>
<summary>展开</summary>

<ul>
<li>拥塞控制主要由四个算法组成：<strong>慢启动(Slow Start)、拥塞避免(Congestion voidance)、快速重传 (Fast Retransmit)、快速恢复(Fast Recovery)</strong></li>
</ul>
<ol>
<li>慢启动：刚开始发送数据时, 先把<strong>拥塞窗口(congestion window)设置为一个MSS</strong>(最大报文段长度)的数值, <strong>每收到一个新的确认后, 就把拥塞窗口加1个MSS</strong>. 这样每经过一个传输轮次(或者说是<strong>每经过一个往返时间</strong>RTT), <strong>拥塞窗口的大小就会加倍</strong>. (成指数速度增加发送速率).</li>
</ol>
<p><img src="_v_images/20191129155345024_11142.png" alt="slow start"></p>
<ol start="2">
<li><p>拥塞避免：当<strong>拥塞窗口的大小达到慢开始门限</strong>(slow start threshold)时, 开始执行拥塞避免算法, 拥塞窗口大小不再指数增加, 而是线性增加, 即<strong>每经过一个传输轮次只增加1MSS</strong>.  </p>
<blockquote>
<p>无论在慢启动阶段还是在拥塞避免阶段, 只要发送方判断网络出现拥塞, 对于超时事件,慢开始门限ssthresh设置为出现拥塞时的发送方拥塞窗口值的一半(但不能小于2),  拥塞窗口cwnd重新设置为1, 执行慢启动算法. (若不使用快速重传 TCP Tahoe版本, 对于三个重复ACK也是这样处理)</p>
</blockquote>
</li>
<li><p>快速重传：快重传要求接收方在收到一个<strong>失序的报文段后就立即发出重复确认</strong>(为的是使发送方及早知道有报文段没有到达对方)而不要等到自己发送数据时捎带确认. 快重传算法规定, 发送方只要一连<strong>收到三个重复确认</strong>就应当<strong>立即重传对方尚未收到的报文段</strong>, 而不必继续等待设置的重传计时器时间到期.  </p>
</li>
</ol>
<p><img src="_v_images/20191129161026032_32431.png" alt="快重传"></p>
<ol start="4">
<li>快速恢复：当发送方连续<strong>收到三个重复确认时, 就把慢开始门限ssthresh为原窗口大小的一半</strong>, 然后<strong>执行拥塞避免算法(线性增大拥塞窗口)</strong>. 不执行慢开始算法的原因：因为如果网络出现拥塞的话就不会收到好几个重复的确认, 所以发送方认为现在网络可能没有出现拥塞. <strong>拥塞窗口cwnd = ssthresh(减半后) + 3MSS</strong>. 这样做的理由是：既然发送方收到三个重复的确认, 就表明有三个分组已经离开了网络. 这三个分组不再消耗网络的资源而是停留在接收方的缓存中. 可见现在网络中减少了三个分组. 因此可以适当把拥塞窗口扩大些. </details>

</li>
</ol>
<h3 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h3><ol>
<li>TCP是面向连接的, UDP是无连接的; <details>
<summary>连接与无连接</summary>

</li>
</ol>
<p>TCP需要建立连接, 维护连接和释放连接. 需要<strong>维护分组之间的状态信息</strong>(如发送端记录数据发送时间, 通过序列号确认号来判断数据发送与确认情况)以保证数据传输的可靠有序<br>UDP发送数据之前不需要建立连接, 每个<strong>分组的处理都彼此独立</strong></p>
</details>

<ol start="2">
<li>TCP是可靠的, UDP不可靠; <details>
<summary>什么是可靠/不可靠? </summary></li>
</ol>
<ul>
<li>可靠: <ul>
<li>通过 TCP 连接传输的数据无差错, 不丢失, 按顺序到达. </li>
<li>TCP 报文头里面的序号能使 TCP 的数据按序到达</li>
<li>报文头里面的确认序号能保证不丢包, 累计确认及超时重传机制</li>
</ul>
</li>
<li>不可靠: UDP接收方收到报文后, 不需要给出任何确认</details>
</li>
</ul>
<ol start="3">
<li><p>TCP只支持点对点通信, 全双工; UDP支持一对一(单播)、一对多(广播)、多对一、多对多(多播); </p>
</li>
<li><p>TCP是面向字节流的, UDP是面向报文的; </p>
<details>
<summary>面向字节流/报文什么意思? </summary>
</li>
</ol>
<ul>
<li>面向字节流是指发送数据时以字节为单位. 如果发送的字节数太长, 会被拆分成多个TCP的数据包发出; 如果发送的字节数太短, 就会先在缓冲区里等待, 等到缓冲区长度合适, 或者其他合适的时机发送出去</li>
<li>面向报文是指 发送方的UDP对应用程序交下来的报文, 在添加首部后就向下交付IP层. UDP<strong>对应用层交下来的报文, 既不合并, 也不拆分</strong>.</details>
</li>
</ul>
<ol start="5">
<li>UDP能够明确区分两个数据包, 避免粘包问题; 而TCP存在粘包问题.<details>
<summary>粘包</summary></li>
</ol>
<ul>
<li>粘包问题中的”包”, 是指的应用层的数据包; </li>
<li>在TCP的协议头中, 没有”报文长度”字段, 但是有一个序号字段; </li>
<li>对于传输层, TCP报文按照序号排好序放在缓冲区中; </li>
<li>对于应用层, 收到的只是一串连续的字节数据. <strong>无法得知从哪个部分开始到哪个部分是一个完整的应用层数据包</strong>.</details>
</li>
</ul>
<ol start="6">
<li>TCP有拥塞控制机制和流量控制, UDP没有. UDP仅提供了运输层最基本的多路分级/多路复用, 和差错检测的功能. 网络出现的拥塞不会使源主机的发送速率降低, 这对某些实时应用是很重要的, 比如媒体通信, 游戏; </li>
<li>TCP首部开销(20字节)比UDP首部开销(8字节)要大</li>
<li>TCP的主机需要维持复杂的连接状态表, UDP 的主机不需要.</li>
</ol>
<h3 id="什么时候选择TCP-什么时候选UDP"><a href="#什么时候选择TCP-什么时候选UDP" class="headerlink" title="什么时候选择TCP, 什么时候选UDP?"></a>什么时候选择TCP, 什么时候选UDP?</h3><details>
<summary>展开</summary>

<ul>
<li><p>对某些<strong>实时性要求比较高</strong>的情况,选择<strong>UDP</strong>, 比如游戏, 媒体通信, 实时视频流(直播), 即使<strong>出现传输错误也可以容忍</strong>; </p>
</li>
<li><p>对于<strong>大量连接, 长连接以及大量传输数据, 优先考虑UDP</strong>(可靠传输).</p>
</li>
<li><p>对于<strong>有限连接(连接数较少)且为短连接时有限考虑TCP</strong>.</p>
</li>
<li><p>对于<strong>要求传输的内容可靠, 不出现丢失</strong>的情况, 如互联网HTTP, 文件传输FTP, 电子邮件SMTP等</p>
</li>
<li><p>如果数据要求完整,不允许任何错误发生, 应用层开放的协议, 例如http, ftp: 建议选择tcp, 几乎是唯一选择.</p>
</li>
<li><p>大量连接:</p>
<ul>
<li>长连接 :<ul>
<li>少量数据传输: 优先考虑udp可靠传输 , tcp建议在20000连接以下(连接数较少)使用.</li>
<li>大流量数据传输: 优先使用udp可靠传输, 只有在10000连接以下(连接数较少)可以考虑tcp </li>
</ul>
</li>
<li>短连接:<ul>
<li>少量数据传输: 建议使用udp标准模式, 加入序列号; 如果连接上限不超2万(连接数较少),可以考虑tcp</li>
</ul>
</li>
<li>大流量数据传输: 10000连接以下考虑tcp; 其他情况使用udp可靠传输</li>
<li>PS: 在遇到<strong>海量连接的情况下,建议优先考虑udp可靠传输</strong>, 使用tcp,由于tcp/ip栈的链表实现的影响,连接越多,性能下降越快,而udp可以实现队列,是一条平滑的直线,几乎没有性能影响.</li>
</ul>
</li>
<li><p>有限连接: 连接数通常小于2000 , 一般每服务器为几百到1000左右</p>
<ul>
<li>长连接: 除非有数据的实时性要求,优先考虑tcp,否则使用udp可靠传输.        </li>
<li><strong>短连接: 优先考虑tcp</strong>. 在有限连接的情况下,使用tcp可以减少代码的复杂性, 增加广泛的移植性, 并且不需要考虑性能问题.  </li>
</ul>
</li>
<li><p>允许丢包,甚至可以乱序</p>
<ul>
<li>对实时性要求比较高, 例如voip , 那么udp是最优选择.</li>
<li>部分数据允许丢包,部分数据要求完整,部分有实时性要求,通常这样的需求是出现在游戏里, 这时候, 基于udp协议改造的udp多路可靠传输(同时支持不可靠模式), 基本是唯一能满足的, 当然也可以使用tcp来传输要求完整的数据,但是通常不建议, 因为同时使用tcp和udp传输数据, 会导致代码臃肿复杂度增加, udp可靠传输完全可以替代tcp.</li>
<li>部分数据优先传输, 部分可丢弃数据在规定时效内传输, 这通常是实时视频流, 在有限连接模式下,可以考虑tcp+udp , 但是通常, 可靠udp传输是最好的选择.  </li>
</ul>
</li>
</ul>
</details>

<h3 id="HTTP可以使用UDP吗"><a href="#HTTP可以使用UDP吗" class="headerlink" title="HTTP可以使用UDP吗?"></a>HTTP可以使用UDP吗?</h3><details>
<summary>展开</summary>

<p>可以. </p>
<ul>
<li>HTTP/1和HTTP/2是基于TCP协议.</li>
<li>HTTP/3是基于传输层协议QUIC, 而QUIC就是基于UDP协议的.</li>
</ul>
</details>


<h3 id="TCP如何保证传输的可靠性"><a href="#TCP如何保证传输的可靠性" class="headerlink" title="TCP如何保证传输的可靠性"></a>TCP如何保证传输的可靠性</h3><details>
<summary>展开</summary>

<ol>
<li>数据包<strong>校验</strong></li>
<li>对<strong>失序数据包重新排序</strong>(TCP报文具有序列号)</li>
<li><strong>丢弃重复</strong>数据</li>
<li><strong>应答机制</strong>: 接收方收到数据之后, 会发送一个确认(通常延迟几分之一秒)</li>
<li><strong>超时重传</strong>: 发送方发出数据之后, 启动一个定时器, 超时未收到接收方的确认, 则重新发送这个数据; </li>
<li><strong>流量控制</strong>: 确保接收端能够接收发送方的数据而不会缓冲区溢出</li>
<li>TCP面向连接, 维护了各种状态(SYN_SENT, …, ESTABLISH, .. CLOSE)以保证收发双方能够正确处理数据包</details>

</li>
</ol>
<h2 id="应用层：HTTP和HTTPS"><a href="#应用层：HTTP和HTTPS" class="headerlink" title="应用层：HTTP和HTTPS"></a>应用层：HTTP和HTTPS</h2><h3 id="HTTP和HTTPS有什么区别"><a href="#HTTP和HTTPS有什么区别" class="headerlink" title="HTTP和HTTPS有什么区别?"></a>HTTP和HTTPS有什么区别?</h3><details>
<summary>展开</summary>

<ol>
<li><strong>端口不同</strong>：HTTP使用的是80端口, HTTPS使用443端口; </li>
<li>HTTP(超文本传输协议)信息是<strong>明文传输</strong>; HTTPS运行在SSL(Secure Socket Layer)/TLS(Transport Layer Security 安全传输层协议, 相当于SSL新版本)之上, 添加了<strong>加密和认证机制</strong>, 更加安全, 但由于加密解密会带来更大的CPU和内存开销; </li>
<li><strong>HTTPS通信需要证书</strong>, 一般需要向证书颁发机构(CA)购买</details>

</li>
</ol>
<h3 id="HTTPS的连接过程"><a href="#HTTPS的连接过程" class="headerlink" title="HTTPS的连接过程?"></a>HTTPS的连接过程?</h3><p>![https时序图](_v_images/20210223233633909_8123.jpg =530x)</p>
<details>
<summary>展开</summary>

<ol>
<li>客户端向服务器发送请求, 同时<strong>发送客户端支持的一套加密规则</strong>(包括对称加密、非对称加密、摘要算法); </li>
<li>服务器从中选出一组加密算法与HASH算法(若没有符合的算法则断开连接), 并<strong>将自己的身份信息以证书的形式发回给客户端浏览器</strong>. 证书里面包含了网站地址, <strong>加密公钥</strong>(用于非对称加密), 以及<strong>证书的颁发机构</strong>等信息(证书中的私钥只能用于服务器端进行解密); </li>
<li>客户端<strong>验证服务器的合法性</strong>, 包括：证书是否过期, CA 是否可靠, 发行者证书的公钥能否正确解开服务器证书的”发行者的数字签名”, 服务器证书上的域名是否和服务器的实际域名相匹配. 若证书无效则停止HTTPS请求.</li>
<li>如果证书受信任, 或者用户接收了不受信任的证书, 浏览器会生成一个<strong>用于对称算法的随机密钥</strong>, 并<strong>用服务器提供的公钥加密</strong>(采用非对称算法对密钥加密).</li>
<li>浏览器生成握手信息, 并使用Hash算法对握手消息进行<strong>摘要</strong>计算, 并对握手信息和摘要使用之前产生的对称密钥加密; 将加密后的随机密钥和握手信息及摘要一起发送给服务器; </li>
<li>服务器使用自己的私钥解密, 得到对称加密的密钥, 用这个密钥解密出握手信息和Hash摘要值, 并对握手信息进行摘要与接收到的握手消息比对是否一致; 如果一致(防篡改), <strong>服务器使用对称加密的密钥加密握手消息及摘要发给客户端浏览器</strong>; </li>
<li>浏览器<strong>解密并验证摘要</strong>, 若一致, 则握手结束. 之后的<strong>数据传送都使用对称加密的密钥</strong>进行加密<br>总结：非对称加密算法用于在握手过程中加密生成的密码; 对称加密算法用于对真正传输的数据进行加密; HASH算法用于验证数据的完整性. </details>

</li>
</ol>
<h3 id="如何确定网址用HTTP还是HTTPS"><a href="#如何确定网址用HTTP还是HTTPS" class="headerlink" title="如何确定网址用HTTP还是HTTPS?"></a>如何确定网址用HTTP还是HTTPS?</h3><details>
<summary>展开</summary>

<ol>
<li>浏览器默认使用 HTTP 去访问网址</li>
<li>服务器响应使用HTTP状态码<strong>302或301进行重定向</strong>, 服务器把所有的HTTP流量跳转到HTTPS(但这样需要每次访问都重定向需要访问服务器两次, 且中间人可能在第一次访问站点时劫持用户).<br>![HSTS时序图](_v_images/20210224001202088_19966.jpg =540x)</li>
<li>(为解决上述问题)引入<strong>HSTS</strong>(HTTP Strict-Transport-Security, HTTP严格传输安全协议), 用户浏览器在访问站点的时候强制使用HTTPS. 具体来讲, 使用HTTP访问服务器时, 服务器给浏览器的<strong>响应中增加<code>Strict-Transport-Security</code>这个HTTP字段, 强制浏览器在一段时间内访问该站点时使用HTTPS</strong>.</li>
<li>使用HSTS时, 当浏览器没有当前网站的HSTS信息的时候, 或者第一次访问网站的时候, 依然需要一次明文的HTTP请求和重定向才能切换到HTTPS, 以及刷新HSTS信息. HSTS应对上述问题, 在浏览器里<strong>内置一个列表HTST Preload List</strong>, 在这个列表里的域名, 无论何时、何种情况, 浏览器都只使用HTTPS发起连接. 这个列表由Google Chromium维护(服务器需要向其提交申请才能加入列表).<ul>
<li>Ref: <a href="https://help.trustasia.com/what-is-hsts/">HSTS概览</a></details>

</li>
</ul>
</li>
</ol>
<h3 id="HTTPS连接的时候-怎么确定收到的包是服务器发来的-中间人攻击"><a href="#HTTPS连接的时候-怎么确定收到的包是服务器发来的-中间人攻击" class="headerlink" title="HTTPS连接的时候, 怎么确定收到的包是服务器发来的(中间人攻击)?"></a>HTTPS连接的时候, 怎么确定收到的包是服务器发来的(中间人攻击)?</h3><details>
<summary>展开</summary>

<p>![04095322_Ey4I](_v_images/20210224215020750_18194.jpg =550x)</p>
<ul>
<li>中间人截取客户端发送给服务器的请求, 然后<strong>伪装成客户端与服务器进行通信</strong>; 将服务器返回给客户端的内容发送给客户端, <strong>伪装成服务器与客户端进行通信</strong>. 通过这样的手段, 便可以获取客户端和服务器之间通信的所有内容. </li>
<li>具体来讲, 中间人通过截取服务器发送给客户端的公钥, 便能解密客户端发送给服务器的对称加密的密钥, 然后在使用自己生成的对称加密密钥与服务器通信. 并利用客户端的对称加密密钥与客户端进行通信.</li>
<li>使用中间人攻击手段, <strong>必须要让客户端信任中间人的证书</strong>, 如果客户端不信任, 则这种攻击手段也无法发挥作用.</li>
<li>预防: <ul>
<li>针对安全性要求比较高的网站, 可采取<strong>客户端预埋证书</strong>的方式锁死证书, <strong>只有当客户端证书和服务端的证书完全一致的情况下才允许通信</strong>, 如一些银行类的app, 但这种方式面临一个问题, 证书过期的问题, 因证书有一定的有效期, 当预埋证书过期了, 只有通过强制更新或者要求用户下载证书来解决. </li>
<li>针对安全性要求一般的app, 可采用通过<strong>校验域名, 证书有效性、证书关键信息及证书链的方式</strong></li>
</ul>
</li>
</ul>
</details>

<h3 id="什么是对称加密、非对称加密-区别是什么"><a href="#什么是对称加密、非对称加密-区别是什么" class="headerlink" title="什么是对称加密、非对称加密? 区别是什么?"></a>什么是对称加密、非对称加密? 区别是什么?</h3><details>
<summary>展开</summary>

<ul>
<li>对称加密：加密和解密采用相同的密钥. 如：DES、AES</li>
<li>非对称加密：需要两个密钥：公钥和私钥. 如果用公钥加密, 需要用私钥才能解密. (一般基于数学难题) 如：RSA, 椭圆曲线加密</li>
<li>区别：对称加密速度更快, 通常用于大量数据的加密; 非对称加密安全性更高(不需要传送私钥), 一般用于加密对称密钥, 进行数字签名等.</details>

</li>
</ul>
<h3 id="数字签名、报文摘要的原理"><a href="#数字签名、报文摘要的原理" class="headerlink" title="数字签名、报文摘要的原理"></a>数字签名、报文摘要的原理</h3><details>
<summary>展开</summary>

<ul>
<li>数字签名: 发送者A用私钥进行签名, 接收者B用公钥验证签名. 因为除A外没有人有私钥, 所以B相信签名是来自A. A不可抵赖, B也不能伪造报文. 用于保证数据的真实性(防抵赖).</li>
<li>报文摘要: 使用哈希函数: 作用于一任意长度的消息M, 返回一固定长度(通常超过128比特)的散列值. 一般使用迭代结构, 将数据划分为块, 每块使用压缩算法然后迭代. 摘要算法:MD5、SHA. 用于保证数据完整性.<br>![](_v_images/20210224221453476_20608.png =578x)</li>
</ul>
</details>

<h3 id="GET与POST的区别"><a href="#GET与POST的区别" class="headerlink" title="GET与POST的区别?"></a>GET与POST的区别?</h3><details>
<summary>展开</summary>

<ul>
<li>GET一般用于从服务器<strong>获取资源,</strong> 不管调用多少次接口, 结果都不会改变, 本身<strong>不会对资源产生影响, 是幂等的</strong>; 而POST一般用于<strong>修改数据, 有可能改变服务器上的资源, 不是幂等的</strong></li>
<li>请求形式上：GET请求的数据<strong>附在URL之后</strong>, 在HTTP请求头中(以<code>?</code>分割URL和传输数据, 参数之间以<code>&amp;</code>相连); POST请求的数据<strong>在请求体中</strong></li>
<li>GET<strong>只接受ASCII字符(子集, 部分需要转码)的参数的数据类型</strong>; POST对数据类型没有要求, 也允许二进制数据 (GET请求只能进行url编码; 而POST支持多种编码方式)</li>
<li>安全性：GET请求<strong>可被缓存、产生的URL可保存为书签、请求参数保留到历史记录</strong>, 且其请求<strong>数据明文出现在URL中</strong>; POST的<strong>参数不会被保存</strong>, 除非手动设置否则不会被缓存, 安全性相对较高; </li>
<li>GET的<strong>数据大小有限制</strong>(http协议并没有硬性限制, 而是与浏览器、服务器、操作系统有关, 一般最长为2KB);  而POST数据大小无限制(实际取决于服务器的设置和内存大小)</li>
<li>GET在浏览器<strong>回退时是无害</strong>的, 回退后浏览器再缓存中拿结果; <strong>POST会再次提交请求</strong></details>

</li>
</ul>
<h3 id="Session与Cookie"><a href="#Session与Cookie" class="headerlink" title="Session与Cookie"></a>Session与Cookie</h3><h4 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h4><h5 id="Cookie工作原理"><a href="#Cookie工作原理" class="headerlink" title="Cookie工作原理"></a>Cookie工作原理</h5><ol>
<li>浏览器端第一次发送请求到服务器端</li>
<li>服务器端创建Cookie, 该<strong>Cookie中包含用户的信息</strong>, 然后将该Cookie<strong>发送到浏览器端</strong></li>
<li>浏览器端再次访问服务器端时会携带服务器端创建的Cookie</li>
<li>服务器端通过Cookie中携带的数据区分不同的用户<br>![Cookie创建过程](_v_images/20210224232136304_18164.png =547x)<h5 id="Session的工作原理"><a href="#Session的工作原理" class="headerlink" title="Session的工作原理"></a>Session的工作原理</h5></li>
<li>浏览器端第一次发送请求到服务器端, 服务器端创建一个Session, 同时会创建一个特殊的Cookie (name为JSESSIONID的固定值, value为session对象的ID), 然后将该Cookie发送至浏览器端</li>
<li>浏览器端发送第(N&gt;1)次请求到服务器端, 浏览器端访问服务器端时就会携带该name为JSESSIONID的Cookie对象</li>
<li>服务器端根据name为JSESSIONID的Cookie的value(sessionId), 去查询Session对象, 从而区分不同用户<ul>
<li>name为JSESSIONID的Cookie不存在(关闭或更换浏览器), 返回1中重新去创建Session与特殊的Cookie</li>
<li>name为JSESSIONID的Cookie存在, 根据value中的SessionId去寻找session对象</li>
<li>value为SessionId不存在**(Session对象默认存活30分钟)**, 返回1中重新去创建Session与特殊的Cookie</li>
<li>value为SessionId存在, 返回session对象<br>![Session工作原理](_v_images/20210224232446415_16137.png =550x)</li>
</ul>
</li>
</ol>
<h4 id="共同之处："><a href="#共同之处：" class="headerlink" title="共同之处："></a>共同之处：</h4><p>cookie和session都是用来跟踪浏览器用户身份的会话方式.<br>Cookie通过在客户端记录信息确定用户身份, Session通过在服务器端记录信息确定用户身份. </p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul>
<li>存储位置不同<ul>
<li>cookie的数据信息存放在<strong>客户端浏览器</strong>上</li>
<li>session的数据信息存放在<strong>服务器</strong>上. </li>
</ul>
</li>
<li>存储容量不同<ul>
<li>单个cookie保存的<strong>数据&lt;=4KB, 一个站点最多保存20个Cookie</strong></li>
<li>对于session没有限制, 但出于对服务器端的性能考虑, session内不要存放过多的东西, 并且设置session删除机制. </li>
</ul>
</li>
<li>存储方式不同<ul>
<li>cookie中只能保存<strong>ASCII字符串</strong>, 并需要通过编码方式存储Unicode字符或者二进制数据</li>
<li>session中能够存储任何类型的数据, 最好只存储用户信息相关的数据</li>
</ul>
</li>
<li>隐私策略不同<ul>
<li>cookie<strong>对客户端是可见的</strong>, 第三方可以分析存放在本地的cookie, 所以它是不安全的</li>
<li>session存储在服务器上, <strong>对客户端是透明的</strong>, 不存在敏感信息泄漏的风险. </li>
</ul>
</li>
<li>有效期上不同<ul>
<li>开发者可以通过设置cookie的属性, 达到<strong>使cookie长期有效</strong>的效果(maxAge决定着Cookie的有效期, 单位为秒; 存在浏览器进程中的Cookie关闭浏览器失效, 长期有效的Cookie一般被存于磁盘)</li>
<li>session依赖于名为JSESSIONID的cookie, 而cookie JSESSIONID的过期时间默认为-1(由于该cookie的时限), 只需关闭窗口该session就会失效. 此外服务器会把长时间没有活动的Session从服务器内存中清除, Session默认失效时间为30分钟左右. 因而<strong>session不能达到长期有效</strong>的效果</li>
</ul>
</li>
<li>服务器压力不同<ul>
<li>cookie保管在客户端, 不占用服务器资源. 对于并发用户十分多的网站, cookie是很好的选择. </li>
<li>session是保管在服务器端的, 每个用户都会产生一个session. 假如并发访问的用户十分多, 会产生十分多的session, 耗费大量的内存. </li>
</ul>
</li>
<li>浏览器支持不同<ul>
<li>假如客户端浏览器不支持cookie：<ul>
<li>cookie是<strong>需要客户端浏览器支持</strong>的, 假如客户端禁用了cookie, 或者不支持cookie, 则会话跟踪会失效. </li>
<li>运用session需要使用<strong>URL地址重写的方式</strong>, 一切用到session程序的URL都要进行URL地址重写, 否则session会话跟踪还会失效. </li>
</ul>
</li>
<li>假如客户端支持cookie：<ul>
<li>cookie既能够设为本浏览器窗口以及子窗口内有效, 也能够设为一切窗口内有效. </li>
<li>session只能在本窗口以及子窗口内有效(假如两个浏览器窗口互不相干, 它们将运用两个不同的Session)</li>
</ul>
</li>
</ul>
</li>
<li>跨域支持上不同<ul>
<li>cookie<strong>支持跨域名</strong>访问</li>
<li>session不支持跨域名访问. </li>
</ul>
</li>
</ul>
<h3 id="从输入网址到获得页面的过程"><a href="#从输入网址到获得页面的过程" class="headerlink" title="从输入网址到获得页面的过程?"></a>从输入网址到获得页面的过程?</h3><h4 id="1-DNS域名解析"><a href="#1-DNS域名解析" class="headerlink" title="1. DNS域名解析"></a>1. DNS域名解析</h4><p>查询 DNS, 获取域名对应的IP地址</p>
<ol>
<li>查找<strong>浏览器缓存</strong>: 浏览器会缓存DNS记录一段时间</li>
<li>查找<strong>系统缓存</strong>:  从本地hosts文件中查找是否有存储的DNS信息</li>
<li>查找<strong>路由器缓存</strong>: 若之前访问过相应网站, 一般路由器也会缓存信息</li>
<li>查找<strong>ISP(本地DNS服务器)的DNS缓存</strong>——从网络服务商(例如电信)的DNS缓存信息中查找. </li>
<li>向根域名服务器查找: 如果经由以上方式都没找到, 则<strong>向根域名服务器发起递归查询或者迭代查询</strong>域名对应的IP地址. 根域名服务器把请求转发到TLD(顶级域)DNS服务器, 在转发至权威DNS服务器, 逐层查找该域名的对应数据, 直到获得最终解析结果或失败的相应.</li>
</ol>
<ul>
<li>递归查询: 如果主机所询问的本地域名服务器不知道被查询的域名的IP地址, 那么<strong>本地域名服务器就以DNS客户的身份, 向其它根域名服务器继续发出查询请求报文</strong>, 返回的查询结果是所要查询的IP地址或者报错. <strong>主机向本地域名服务器的查询一般都是采用递归查询</strong></li>
<li>迭代查询: 当根域名服务器收到本地域名服务器发出的迭代查询请求报文时, <strong>要么给出所要查询的IP地址, 要么返回能解答该查询的服务器列表</strong>,  然后本地服务器对列表进行后续的查询. 一般本地DNS服务器向根服务器, TLD DNS服务器和权威DNS服务器是迭代查询.<br>![DNS递归查询和迭代查询](_v_images/20210225215456412_20336.png =540x)<h4 id="2-建立TCP连接"><a href="#2-建立TCP连接" class="headerlink" title="2. 建立TCP连接"></a>2. 建立TCP连接</h4>浏览器获得域名对应的IP地址以后, 浏览器<strong>向服务器请求建立链接, 发起TCP三次握手</strong><h4 id="3-发送HTTP请求"><a href="#3-发送HTTP请求" class="headerlink" title="3. 发送HTTP请求"></a>3. 发送HTTP请求</h4>TCP/IP连接建立后, 浏览器向服务器<strong>发送HTTP请求</strong><h4 id="4-服务器处理请求"><a href="#4-服务器处理请求" class="headerlink" title="4. 服务器处理请求"></a>4. 服务器处理请求</h4>服务器接收到这个请求, 并根据<strong>路径参数映射到特定的请求处理器进行处理</strong>, 控制器(Controller)从模型(Model)和视图(View)中获取各种数据信息进行处理, 最后<strong>视图(View)将数据渲染为HTML返回</strong>给浏览器<h4 id="5-浏览器显示页面信息"><a href="#5-浏览器显示页面信息" class="headerlink" title="5.浏览器显示页面信息"></a>5.浏览器显示页面信息</h4></li>
</ul>
<ol>
<li>浏览器<strong>边解析边渲染.</strong> 浏览器解析HTML文件构建DOM树, 根据CSS构建渲染树, 若遇到对<strong>js文件、css文件及图片等静态资源的引用, 则重复上述步骤并向服务器(异步)请求</strong>这些资源. </li>
<li>浏览器等到渲染树构建完成后, 开始布局渲染树并<strong>将其绘制到屏幕</strong>上, 最终向用户呈现一个完整的页面.(加载过程遇到JS文件要等到其由JS解析引擎解析加载执行完毕后再继续渲染).</li>
</ol>
<h3 id="HTTP请求有哪些常见状态码"><a href="#HTTP请求有哪些常见状态码" class="headerlink" title="HTTP请求有哪些常见状态码?"></a>HTTP请求有哪些常见状态码?</h3><p><a href="https://www.w3cschool.cn/http/g9prxfmx.html">HTTP 响应代码</a></p>
<ul>
<li>2xx状态码：成功响应.  <ul>
<li><strong>200 OK 请求成功</strong></li>
</ul>
</li>
<li>3xx状态码：重定向 <ul>
<li><strong>301 Moved Permanently 永久重定向</strong>. 请求的资源已被永久的移动到新URI, 返回信息会包括新的URI, 浏览器会自动定向到新URI, 今后任何<strong>新的请求都应使用新的URI</strong>代替</li>
<li><strong>302 Found 暂时重定向</strong>. 请求的资源现在临时从不同的 URI 响应请求. 由于这样的重定向是临时的, 客户端应当继续向<strong>原有地址发送以后的请求</strong></li>
<li><strong>304 Not Modified 未修改</strong>. 客户端发送了一个带条件的 GET 请求且该请求已被允许, 而(自上次访问以来或者根据请求的条件)<strong>请求的资源并没有修改, 不返回任何资源</strong>, 即禁止包含消息体. </li>
</ul>
</li>
<li>4xx状态码：客户端错误<ul>
<li><strong>400 Bad Request 请求错误</strong>. 客户端请求的语法错误, 服务器无法理解; 或者请求的参数错误</li>
<li><strong>401 Unauthorized 未授权</strong>. 当前请求<strong>需要用户身份验证</strong></li>
<li><strong>403 Forbidden 禁止</strong>. 服务器已经理解请求, 但是<strong>拒绝执行</strong></li>
<li><strong>404 Not Found 未找到</strong>. 服务器无法根据客户端的请求找到资源</li>
</ul>
</li>
<li>5xx状态码：服务器错误<ul>
<li><strong>500 Internal Server Error 服务器内部错误</strong>. 服务器内部错误, 遇到了不知道如何处理的情况</li>
<li><strong>501 Not Implemented 服务不可用</strong> 服务器不支持请求的功能, 无法完成请求</li>
</ul>
</li>
</ul>
<h3 id="OSI七层模型与TCP-IP五层模型"><a href="#OSI七层模型与TCP-IP五层模型" class="headerlink" title="OSI七层模型与TCP/IP五层模型"></a>OSI七层模型与TCP/IP五层模型</h3><p>![OSI七层模型与TCP/IP五层模型](_v_images/20210225225813101_3369.png =482x)<br>![OSI参考模型](_v_images/20210225225837935_32694.png =491x)</p>
<ul>
<li>应用层: 为应用程序提供服务, 各种<strong>应用程序协议</strong></li>
<li>表示层: 数据<strong>格式转化</strong>, 数据<strong>加密解密</strong>, 数据<strong>压缩解压缩</strong></li>
<li>会话层: 建立,管理和终止<strong>实体间的会话连接</strong></li>
<li>传输层: 数据的<strong>分段及重组</strong>, 提供<strong>进程间的数据传输</strong>服务</li>
<li>网络层: 将<strong>数据从源端传送到目的端</strong>, 逻辑寻址, <strong>路由选择, 分组转发</strong></li>
<li>数据链路层: 实现数据在<strong>网络相邻结点之间的传输</strong>, 差错检测</li>
<li>物理层: 在介质上传输比特流</li>
</ul>
<details>
<summary>路由器、交换机位于哪一层? </summary>

<ul>
<li>路由器位于网络层, 根据IP地址进行寻址; </li>
<li>交换机位于链路层, 根据MAC地址进行寻址</details>

</li>
</ul>
<h2 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h2><h3 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类?"></a>IP地址的分类?</h3><p>![IP address](_v_images/20191201085151639_2895.png =450x)</p>
<p>路由器仅根据网络号net-id来转发分组, 当分组到达目的网络的路由器之后, 再按照主机号host-id将分组交付给主机; 同一网络上的所有主机的网络号相同. </p>
<h3 id="什么叫划分子网"><a href="#什么叫划分子网" class="headerlink" title="什么叫划分子网?"></a>什么叫划分子网?</h3><p><strong>从主机号host-id借用若干个比特作为子网号</strong>subnet-id<br>子网掩码：网络号和子网号都为1, 主机号为0<br>数据报仍然先按照网络号找到目的网络, 发送到路由器, <strong>路由器再按照网络号和子网号找到目的子网</strong>：将子网掩码与目标地址逐比特与操作, 若结果为某个子网的网络地址, 则送到该子网. </p>
<h3 id="什么是ARP协议-Address-Resolution-Protocol"><a href="#什么是ARP协议-Address-Resolution-Protocol" class="headerlink" title="什么是ARP协议 (Address Resolution Protocol)?"></a>什么是ARP协议 (Address Resolution Protocol)?</h3><ul>
<li>ARP协议<strong>完成了IP地址与物理地址的映射</strong>.</li>
<li>每一个主机都设有一个 ARP 高速缓存, 里面有<strong>所在的局域网上的各主机和路由器的 IP 地址到MAC地址的映射表</strong>. </li>
<li>当源主机要发送数据包到目的主机时, 会先检查自己的ARP高速缓存中<strong>有没有目的主机的MAC地址</strong>, 如果有, 就直接将数据包发到这个MAC地址; 如果没有, 就向<strong>所在的局域网</strong>发起一个ARP请求的广播包(在发送自己的 ARP 请求时, 同时会带上自己的 IP 地址到MAC地址的映射), 收到请求的主机检查自己的IP地址和目的主机的IP地址是否一致, 如果一致, 则<strong>先保存源主机的映射到自己的ARP缓存</strong>, 然后给源主机发送一个ARP响应数据包. 源主机收到响应数据包之后, 先添加目的主机的IP地址与MAC地址的映射, 再进行数据传送. 如果源主机一直没有收到响应, 表示ARP查询失败. </li>
<li>如果所要找的主机和源主机<strong>不在同一个局域网</strong>上, 那么就要通过 ARP 找到一个位于本局域网上的某个(网关)路由器的MAC地址, 然后把分组发送给这个路由器, 让这个路由器把分组转发给下一个网络. 剩下的工作就由下一个网络来做. </li>
</ul>
<h3 id="网络层的面向连接和无连接"><a href="#网络层的面向连接和无连接" class="headerlink" title="网络层的面向连接和无连接"></a>网络层的面向连接和无连接</h3><details>
<summary>展开</summary>

<ul>
<li>无连接的网络服务(数据报服务); 面向连接的网络服务(虚电路服务)</li>
<li>虚电路服务：需要<strong>维护连接</strong>(建立,断开), 所有的<strong>数据包经过相同的路径</strong>, 服务质量有较好的保证</li>
<li>数据报服务：每个数据包含目的地址, <strong>数据路由相互独立</strong>(路径可能变化); 网络尽最大努力交付数据, 但<strong>不保证不丢失、不延迟、不错序</strong>; 网络发生拥塞时, 可能会将一些分组丢弃;<br>![virtual circuit](_v_images/20191201081919108_30577.png =450x)</details>


</li>
</ul>
<h3 id="什么是NAT"><a href="#什么是NAT" class="headerlink" title="什么是NAT"></a>什么是NAT</h3><ul>
<li>NAT: Network Address Translation, 网络地址转换. </li>
<li>用于<strong>内网中的主机和因特网上的主机通信</strong>, 解决IP地址不足的问题.</li>
<li>由NAT路由器<strong>将主机的本地IP地址转换为全球IP地址</strong>, 分为静态转换(转换得到的全球IP地址固定不变, 用于隐藏主机真实IP) 和动态NAT转换(内部网络的私有 IP 地址转换为公用 IP 地址时, IP 地址是不确定, 随机的)</li>
</ul>
<h3 id="RIP-算法是什么"><a href="#RIP-算法是什么" class="headerlink" title="RIP 算法是什么"></a>RIP 算法是什么</h3><ul>
<li>RIP: Routing Information Protocol, 距离矢量路由协议. </li>
<li>每个<strong>路由器维护一张表, 记录该路由器到其它网络的”跳数”</strong>, 路由器到与其<strong>直接连接的网络的跳数是1, 每多经过一个路由器跳数就加1</strong>; 更新该表时和相邻路由器交换路由信息; 路由器允许一个路径最多包含15个路由器, 如果跳数为16, 则不可达. <strong>交付数据报时优先选取距离最短的路径</strong>.<br>(PS：RIP是应用层协议, 为网络层服务：<a href="https://www.zhihu.com/question/19645407">https://www.zhihu.com/question/19645407</a>)</li>
</ul>
<details>
<summary>优缺点</summary>

<ul>
<li>实现简单, 开销小</li>
<li>随着网络规模扩大开销也会增大; </li>
<li>最大距离为15, 限制了网络的规模; </li>
<li>当网络出现故障时, 要经过较长的时间才能将此信息传递到所有路由器</details>
</li>
</ul>
]]></content>
  </entry>
</search>
